import {
    m as e,
    b as t,
    f as n,
    n as a,
    S as r,
    h as i,
    _ as s,
    c as o,
    i as c,
    t as d,
    a as l,
    k as p,
    A as u,
} from './3.DK8xU-ow.chunk.js';
import {
    a7 as g,
    eG as h,
    eH as m,
    eI as v,
    eJ as f,
    eK as y,
    b7 as _,
    eL as I,
    bz as S,
    eM as b,
    eN as C,
    a8 as w,
    b5 as T,
    W as E,
    u as k,
    eO as A,
    d0 as P,
    eP as O,
    eQ as q,
    eR as F,
    bD as U,
    eS as j,
    eT as x,
    eU as M,
    eV as L,
    eW as N,
    eX as z,
    eY as D,
    eZ as G,
    e_ as R,
    e$ as V,
    f0 as B,
    f1 as H,
    f2 as Q,
    f3 as W,
    f4 as J,
    f5 as X,
    f6 as Y,
    f7 as Z,
    f8 as K,
    f9 as $,
    fa as ee,
    fb as te,
    fc as ne,
    fd as ae,
    fe as re,
    ff as ie,
    fg as se,
    fh as oe,
    fi as ce,
    fj as de,
    fk as le,
    fl as pe,
    fm as ue,
    fn as ge,
    fo as he,
    fp as me,
    fq as ve,
    fr as fe,
    fs as ye,
    ft as _e,
    fu as Ie,
    fv as Se,
    c1 as be,
    N as Ce,
    at as we,
    L as Te,
    fw as Ee,
    H as ke,
    cI as Ae,
    aT as Pe,
    fx as Oe,
    X as qe,
    aN as Fe,
    w as Ue,
    fy as je,
    cp as xe,
    e8 as Me,
    O as Le,
    fz as Ne,
    fA as ze,
    fB as De,
    fC as Ge,
    i as Re,
    aY as Ve,
    x as Be,
    fD as He,
    fE as Qe,
    fF as We,
    em as Je,
    J as Xe,
    am as Ye,
    d_ as Ze,
    fG as Ke,
    aU as $e,
    P as et,
    bI as tt,
    bT as nt,
    fH as at,
    T as rt,
    fI as it,
    fJ as st,
    fK as ot,
    fL as ct,
    fM as dt,
    eh as lt,
    fN as pt,
    fO as ut,
    fP as gt,
    fQ as ht,
    fR as mt,
    as as vt,
    fS as ft,
    ev as yt,
    dS as _t,
    fT as It,
    fU as St,
    fV as bt,
    aj as Ct,
    fW as wt,
    fX as Tt,
    fY as Et,
    fZ as kt,
    $ as At,
    f_ as Pt,
    f$ as Ot,
    g0 as qt,
    g1 as Ft,
    ah as Ut,
    ac as jt,
    g2 as xt,
    g3 as Mt,
    g4 as Lt,
    g5 as Nt,
    g6 as zt,
    a2 as Dt,
    g7 as Gt,
    g8 as Rt,
    an as Vt,
    g9 as Bt,
    ga as Ht,
    gb as Qt,
    gc as Wt,
    gd as Jt,
    R as Xt,
    C as Yt,
    ge as Zt,
    dk as Kt,
    ar as $t,
    gf as en,
    aQ as tn,
    gg as nn,
    dP as an,
    gh as rn,
    bV as sn,
    gi as on,
    gj as cn,
    S as dn,
    gk as ln,
    gl as pn,
    gm as un,
    aF as gn,
    gn as hn,
    go as mn,
    gp as vn,
    Q as fn,
    gq as yn,
    gr as _n,
    gs as In,
    gt as Sn,
    dK as bn,
    gu as Cn,
    gv as wn,
    gw as Tn,
    gx as En,
    e as kn,
    gy as An,
    gz as Pn,
    gA as On,
    gB as qn,
    b4 as Fn,
    Y as Un,
    gC as jn,
    gD as xn,
    b0 as Mn,
    gE as Ln,
    b1 as Nn,
    p as zn,
    m as Dn,
    gF as Gn,
    y as Rn,
    gG as Vn,
    A as Bn,
    s as Hn,
    cs as Qn,
    U as Wn,
    b2 as Jn,
    gH as Xn,
    D as Yn,
    f as Zn,
    a0 as Kn,
    a1 as $n,
    gI as ea,
    gJ as ta,
    dM as na,
    gK as aa,
    b3 as ra,
    B as ia,
    gL as sa,
    dG as oa,
    gM as ca,
} from './5.DjBaMMVQ.chunk.js';
import { c8 as da, c9 as la, i as pa, ca as ua, cb as ga, f as ha, g as ma, p as va } from './2.duIGFjkW.chunk.js';
import { v as fa, c as ya, h as _a, t as Ia, s as Sa } from './1.D9sKFkGY.chunk.js';
import { i as ba } from './7.qYTqns9Q.chunk.js';
import {
    g as Ca,
    a as wa,
    b as Ta,
    c as Ea,
    l as ka,
    m as Aa,
    d as Pa,
    e as Oa,
    u as qa,
    h as Fa,
    i as Ua,
    j as ja,
    k as xa,
    n as Ma,
    o as La,
    p as Na,
    q as za,
    r as Da,
    s as Ga,
    t as Ra,
    f as Va,
} from './8.DUpLyWw8.chunk.js';
import { j as Ba, e as Ha, k as Qa, i as Wa } from './6.B0_QvnEW.chunk.js';
import { c as Ja } from './9.xhyEK0_l.chunk.js';
import { k as Xa } from './4.C_rgEAoe.chunk.js';
import './10.al-9NYxR.chunk.js';
import './11.DJPUQwQu.chunk.js';

function Ya(e, t) {
    if (0 === e) {
        var n = !1;
        t(0, function (e) {
            2 === e && (n = !0);
        }),
            n || t(2);
    }
}
const Za =
    ((Ka = () => Ya),
    e => (t, n) => {
        if (0 !== t) return;
        let a,
            r = !1;
        const i = (e, t) => {
                a(e, t);
            },
            s = (e, t) => {
                if (0 === e) return (a = t), r ? void i(1) : void n(e, i);
                if (2 === e && t && !r) {
                    r = !0;
                    try {
                        Ka(t)(0, s);
                    } catch (o) {
                        n(2, o);
                    }
                } else n(e, t);
            };
        e(t, s);
    });
var Ka,
    $a = function () {};

function er(e, t) {
    0 === e && t(0, $a);
}

function tr() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return function (e, n) {
        if (0 === e) {
            var a = !1;
            for (
                n(0, function (e) {
                    2 === e && ((a = !0), (t.length = 0));
                });
                0 !== t.length;

            )
                n(1, t.shift());
            a || n(2);
        }
    };
}

function nr(e, t) {
    return [e, t];
}
const ar = ['groupId'];

function rr() {
    return (
        (rr = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        rr.apply(null, arguments)
    );
}
const ir = e => {
        const t = {};
        return (
            'string' == typeof e.customId && (t.custom_id = e.customId),
            _(e.properties) && (t.properties = e.properties),
            t
        );
    },
    sr = e => {
        switch (e.type) {
            case y: {
                const t = rr({}, ir(e), {
                    type: e.type,
                    text: e.text,
                });
                return (
                    e.postback &&
                        (t.postback = {
                            id: e.postback.id,
                            thread_id: e.postback.threadId,
                            event_id: e.postback.eventId,
                            type: e.postback.type,
                            value: e.postback.value,
                        }),
                    t
                );
            }
            case f:
                return rr({}, ir(e), {
                    type: e.type,
                    url: e.url,
                    alternative_text: e.alternativeText,
                });
            case v:
                return rr({}, ir(e), {
                    type: e.type,
                    form_id: e.formId,
                    fields: e.fields.map(e => {
                        if ('group_chooser' === e.type) {
                            if (!e.answer) return e;
                            const t = e.answer,
                                { groupId: n } = t;
                            return rr({}, e, {
                                answer: rr(
                                    {},
                                    (function (e, t) {
                                        if (null == e) return {};
                                        var n = {};
                                        for (var a in e)
                                            if ({}.hasOwnProperty.call(e, a)) {
                                                if (-1 !== t.indexOf(a)) continue;
                                                n[a] = e[a];
                                            }
                                        return n;
                                    })(t, ar),
                                    {
                                        group_id: n,
                                    }
                                ),
                            });
                        }
                        return e;
                    }),
                });
            case m: {
                const t = rr({}, ir(e), {
                    type: e.type,
                    text: e.text,
                    system_message_type: e.systemMessageType,
                });
                return e.recipients && (t.recipients = e.recipients), t;
            }
            case h: {
                const t = rr({}, ir(e), {
                    type: e.type,
                });
                return e.content && (t.content = e.content), t;
            }
        }
    },
    or = e => {
        let { active: t = !0, chat: n, welcomeMessageId: a, continuous: r } = e;
        const i = {
            active: t,
            chat: {},
        };
        if (('boolean' == typeof r && (i.continuous = r), a && 'string' == typeof a && (i.welcome_message_id = a), !n))
            return i;
        const { access: s, thread: o, properties: c } = n;
        return (
            s &&
                s.groupIds &&
                (i.chat.access = {
                    group_ids: s.groupIds,
                }),
            c && (i.chat.properties = c),
            o &&
                (i.chat.thread = (e => {
                    const t = {},
                        { events: n, properties: a } = e;
                    return n && (t.events = n.map(sr)), a && (t.properties = a), t;
                })(o)),
            i
        );
    },
    cr = e =>
        Ba(e).map(e => {
            let [t, n] = e;
            return {
                [t]: n,
            };
        }),
    dr = e => {
        const t = g(['avatar', 'name', 'email'], e);
        return (
            e.sessionFields && (t.session_fields = cr(e.sessionFields)),
            'boolean' == typeof e.nameIsDefault && (t.name_is_default = e.nameIsDefault),
            t
        );
    },
    lr = 'change_region',
    pr = 'check_goals',
    ur = 'destroy',
    gr = 'fail_all_requests',
    hr = 'login_success',
    mr = 'pause_connection',
    vr = 'prefetch_token',
    fr = 'push_received',
    yr = 'push_response_received',
    _r = 'reconnect',
    Ir = 'request_failed',
    Sr = 'response_received',
    br = 'send_request',
    Cr = 'set_chat_active',
    wr = 'set_self_id',
    Tr = 'socket_connected',
    Er = 'socket_disconnected',
    kr = 'socket_recovered',
    Ar = 'socket_unstable',
    Pr = 'start_connection',
    Or = 'update_customer_page',
    qr = 'clear_sensitive_session_state',
    Fr = 'identity_changed';

function Ur() {
    return (
        (Ur = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        Ur.apply(null, arguments)
    );
}
const jr = e => ({
        type: ur,
        payload: {
            reason: e,
        },
    }),
    xr = e => ({
        type: mr,
        payload: {
            reason: e,
        },
    }),
    Mr = function (e) {
        return (
            void 0 === e && (e = !1),
            {
                type: vr,
                payload: {
                    fresh: e,
                },
            }
        );
    },
    Lr = e => ({
        type: _r,
        payload: {
            delay: e,
        },
    }),
    Nr = (e, t, n) => ({
        type: br,
        payload: Ur(
            {
                request: {
                    action: e,
                    payload: t,
                },
            },
            n && {
                source: n,
            }
        ),
    }),
    zr = (e, t) => ({
        type: Cr,
        payload: {
            id: e,
            active: t,
        },
    }),
    Dr = e => ({
        type: wr,
        payload: {
            id: e,
        },
    }),
    Gr = 'CONNECTION_LOST',
    Rr = 'MISDIRECTED_CONNECTION',
    Vr = 'MISSING_CHAT_THREAD',
    Br = 'SDK_DESTROYED',
    Hr = 'connected',
    Qr = 'destroyed',
    Wr = 'disconnected',
    Jr = 'customer_banned',
    Xr = 'product_version_changed',
    Yr = 'logged_out_remotely';

function Zr(e) {
    let { message: t, code: n } = e;
    const a = new Error(t);
    return (a.code = n), a;
}

function Kr(e) {
    var t = (function (e, t) {
        if ('object' != typeof e || !e) return e;
        var n = e[Symbol.toPrimitive];
        if (void 0 !== n) {
            var a = n.call(e, t);
            if ('object' != typeof a) return a;
            throw new TypeError('@@toPrimitive must return a primitive value.');
        }
        return String(e);
    })(e, 'string');
    return 'symbol' == typeof t ? t : t + '';
}

function $r() {
    return (
        ($r = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        $r.apply(null, arguments)
    );
}
const ei = e => e.connection.status,
    ti = (e, t) => e.requests[t],
    ni = e => e.users.self.id,
    ai = (e, t) => {
        const n = e.chats[t];
        return !!n && n.active;
    },
    ri = e => ei(e) === Hr,
    ii = e => {
        var t;
        return {
            'x-region': null != (t = e.region) ? t : '',
        };
    },
    si = e =>
        (e => {
            const { region: t } = e;
            return (
                'https://api' +
                (!t || ('fra' !== t && 'eu-west3' !== t) ? '' : '-fra') +
                (e => {
                    let { env: t } = e;
                    return 'production' === t ? '' : '.' + t;
                })(e) +
                '.livechatinc.com'
            );
        })(e) + '/v3.6/customer',
    oi = (e, t) => {
        let { id: n } = t;
        return $r({}, e, {
            requests: (function (e, t) {
                if (null == e) return {};
                var n = {};
                for (var a in e)
                    if ({}.hasOwnProperty.call(e, a)) {
                        if (-1 !== t.indexOf(a)) continue;
                        n[a] = e[a];
                    }
                return n;
            })(e.requests, [n].map(Kr)),
        });
    },
    ci = (e, t) =>
        $r({}, t, {
            connection: $r({}, t.connection, {
                status: e,
            }),
        });

function di(e) {
    const t = pa,
        n = da(),
        a = la(
            ((r = (e => {
                const {
                    application: t = {},
                    organizationId: n,
                    groupId: a = null,
                    env: r,
                    page: i = null,
                    region: s = null,
                    referrer: o = null,
                    uniqueGroups: c = !1,
                    mobile: d = !1,
                } = e;
                return {
                    application: $r({}, t, {
                        name: 'chat_widget',
                        version: 'a025adc2fe700e616fbd4cc7705667ad319570a4',
                    }),
                    organizationId: n,
                    env: r,
                    groupId: a,
                    chats: {},
                    connection: {
                        status: Wr,
                    },
                    page: i,
                    region: s,
                    referrer: o,
                    requests: {},
                    users: {
                        self: {
                            id: null,
                            type: b,
                        },
                        others: {},
                    },
                    uniqueGroups: c,
                    mobile: d,
                };
            })(e)),
            S(r, {
                [lr]: (e, t) => {
                    let { region: n } = t;
                    return $r({}, e, {
                        region: n,
                    });
                },
                [ur]: e => ci(Qr, e),
                [hr]: e => ci(Hr, e),
                [mr]: e => ci('paused', e),
                [Ir]: oi,
                [Sr]: oi,
                [yr]: oi,
                [br]: (e, t) => {
                    let { promise: n, resolve: a, reject: r, id: i, request: s } = t;
                    return $r({}, e, {
                        requests: $r({}, e.requests, {
                            [i]: {
                                id: i,
                                promise: n,
                                resolve: a,
                                reject: r,
                                request: s,
                            },
                        }),
                    });
                },
                [Cr]: (e, t) => {
                    let { id: n, active: a } = t;
                    return $r({}, e, {
                        chats: $r({}, e.chats, {
                            [n]: $r({}, e.chats[n], {
                                active: a,
                            }),
                        }),
                    });
                },
                [wr]: (e, t) =>
                    $r({}, e, {
                        users: $r({}, e.users, {
                            self: $r({}, e.users.self, {
                                id: t.id,
                            }),
                        }),
                    }),
                [Er]: e => {
                    const t = ei(e);
                    return $r({}, ci(t === Wr ? Wr : 'reconnecting', e), {
                        requests: {},
                    });
                },
                [Or]: (e, t) =>
                    $r({}, e, {
                        page: $r({}, e.page, t),
                    }),
                [qr]: e =>
                    $r({}, e, {
                        chats: {},
                        users: {
                            self: {
                                id: null,
                                type: b,
                            },
                            others: {},
                        },
                        requests: {},
                    }),
                [Fr]: e => e,
            })),
            t(ua(n))
        );
    var r;
    return (a.addSideEffectsHandler = n.add), a;
}
const li = e => {
    let { env: t, organizationId: n, eventName: a } = e;
    return Promise.resolve();
};

function pi() {
    return (
        (pi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        pi.apply(null, arguments)
    );
}
const ui = (e, t) => {
        t.payload.id = w(e.getState().requests);
        const { resolve: n, reject: a, promise: r } = T();
        return (t.payload.promise = r), (t.payload.resolve = n), (t.payload.reject = a), e.dispatch(t), r;
    },
    gi = e => {
        const { organizationId: t, groupId: n, uniqueGroups: a } = e.getState();
        return 'side_storage_' + t + (a ? ':' + n : '');
    },
    hi = (e, t) => {
        const n = E(t),
            r = gi(e);
        return n
            .getItem(r)
            .catch(a)
            .then(e => JSON.parse(e || '{}'))
            .catch(a);
    },
    mi = (e, t) => {
        let { getState: n, dispatch: a } = e;
        const r = (e => e.requests)(n());
        a({
            type: gr,
            payload: {
                rejects: Object.keys(r).map(e => r[e].reject),
                reason: t,
            },
        });
    },
    vi = (e, t, n) => {
        let { getState: a, dispatch: r } = e;
        const i = t.payload.id;
        r({
            type: Ir,
            payload: {
                id: i,
                reject: a().requests[i].reject,
                error: n,
            },
        });
    };

function fi() {
    return (
        (fi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        fi.apply(null, arguments)
    );
}

function yi() {
    return (
        (yi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        yi.apply(null, arguments)
    );
}
const _i = (e, t, n) => ui(e, Nr(t, n, 'login'));

function Ii(e, t, n, i) {
    let s,
        o,
        c = null;
    const d = {
            min: 300,
            max: 6e4,
            jitter: 0.3,
        },
        l = ga(d),
        p = ga(
            yi({}, d, {
                min: 1e3,
            })
        );
    let u = l;
    const g = e => s.dispatch(jr(e)),
        h = () => s.dispatch(Lr(u.duration())),
        m = () => Promise.all([e.getToken(), hi(s, i)]),
        v = e => {
            let [t, n] = e;
            const r = ni(s.getState());
            if (null === r) s.dispatch(Dr(t.entityId));
            else if (r !== t.entityId)
                return (
                    i &&
                        ((e, t) => {
                            E(t).removeItem(gi(e)).catch(a);
                        })(s, i),
                    s.dispatch({
                        type: qr,
                    }),
                    s.dispatch(Dr(t.entityId)),
                    s.dispatch(
                        ((o = {
                            previousId: r,
                            newId: t.entityId,
                        }),
                        {
                            type: Fr,
                            payload: o,
                        })
                    ),
                    [t, {}]
                );
            var o;
            return [t, n];
        },
        f = e => {
            let [n, a] = e;
            const r = s.getState(),
                { application: i, groupId: o, page: d, referrer: l, mobile: p } = r,
                u = {
                    token: n.tokenType + ' ' + n.accessToken,
                    customer: 'function' == typeof t ? dr(t()) : {},
                    customer_side_storage: a,
                    is_mobile: p,
                    application: P(['name', 'version'], i),
                };
            return (
                (u.c = (e => {
                    let [t, n] = e;
                    return (
                        Array.from('' + t + n).reduce(
                            (e, t) => e + t['tAedoCrahc'.split('').reverse().join('')](0),
                            0
                        ) % 1024
                    );
                })((e => [e.organizationId, e.users.self.id])(r))),
                'number' == typeof o && (u.group_id = o),
                i.channelType && (u.application.channel_type = i.channelType),
                null !== d && ((c = d), (u.customer_page = d)),
                null !== l && (u.referrer = l),
                Promise.race([
                    _i(s, O, u),
                    ((g = 15e3),
                    new Promise(e => {
                        setTimeout(e, g);
                    })).then(() =>
                        Promise.reject(
                            Zr({
                                message: 'Request timed out.',
                                code: 'REQUEST_TIMEOUT',
                            })
                        )
                    ),
                ])
            );
            var g;
        };
    return {
        sendLogin: t => {
            var n;
            (s = t),
                null == (n = o) || n.cancel(),
                (o = ((e, t, n) => {
                    let [...a] = e,
                        i = !1;
                    const s = e => {
                        const o = a.shift();
                        r(() => o(e)).then(
                            e => {
                                i || (a.length ? s(e) : t(e));
                            },
                            e => {
                                i || n(e);
                            }
                        );
                    };
                    return (
                        s(),
                        {
                            cancel() {
                                i = !0;
                            },
                        }
                    );
                })(
                    [m, v, f],
                    e => {
                        (o = null),
                            l.reset(),
                            p.reset(),
                            (u = l),
                            (() => {
                                const { page: e } = s.getState();
                                c !== e && _i(s, q, e).catch(a), (c = null);
                            })(),
                            s.dispatch({
                                type: hr,
                                payload: e,
                            });
                    },
                    t => {
                        switch (((o = null), t.code)) {
                            case 'AUTHENTICATION':
                                return e.getFreshToken(), void h();
                            case Gr:
                            case Rr:
                            case Br:
                                return;
                            case 'SSO_IDENTITY_EXCEPTION':
                            case 'SSO_OAUTH_EXCEPTION':
                                return 'server_error' === t.message || 'temporarily_unavailable' === t.message
                                    ? void h()
                                    : void g(t.message);
                            case 'USERS_LIMIT_REACHED':
                                return void s.dispatch(xr(t.code.toLowerCase()));
                            case 'CUSTOMER_BANNED':
                            case 'WRONG_PRODUCT_VERSION':
                                return void g(t.code.toLowerCase());
                            case 'SERVICE_TEMPORARILY_UNAVAILABLE':
                                return (u = p), void h();
                            default:
                                return void h();
                        }
                    }
                ));
        },
        cancel: () => {
            var e;
            null == (e = o) || e.cancel();
        },
    };
}
const Si = ['present'],
    bi = ['statistics'];

function Ci(e, t) {
    if (null == e) return {};
    var n = {};
    for (var a in e)
        if ({}.hasOwnProperty.call(e, a)) {
            if (-1 !== t.indexOf(a)) continue;
            n[a] = e[a];
        }
    return n;
}

function wi() {
    return (
        (wi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        wi.apply(null, arguments)
    );
}
const Ti = {
        [Gr]: 'Connection lost.',
        [Rr]: 'Connected to wrong region.',
    },
    Ei = (e, t) => {
        const n = e.getState();
        switch (t.type) {
            case yr:
            case fr:
                switch (t.payload.action) {
                    case L:
                        return void e.dispatch(zr(t.payload.payload.chatId, !1));
                    case M:
                        return void e.dispatch(zr(t.payload.payload.chat.id, !0));
                    default:
                        return;
                }
            case Sr:
                return t.payload.action === x
                    ? void t.payload.payload.chatsSummary
                          .filter(e => {
                              let { id: t, active: a } = e;
                              return ai(n, t) !== a;
                          })
                          .forEach(t => {
                              let { id: n, active: a } = t;
                              e.dispatch(zr(n, a));
                          })
                    : void 0;
        }
    },
    ki = (e, t) => {
        t.forEach(t => {
            if ('present' in t) {
                const n = Ci(t, Si);
                return void e('user_data', n);
            }
            if (t.type === b) {
                const n = Ci(t, bi);
                return void e('user_data', n);
            }
            e('user_data', t);
        });
    },
    Ai = (e, t, n) => {
        let { emit: r, store: i } = e,
            { payload: s } = t;
        switch (s.action) {
            case J:
                return (
                    s.payload.properties.lc2 &&
                        'queue_pos' in s.payload.properties.lc2 &&
                        r(X, {
                            chatId: s.payload.chatId,
                            threadId: s.payload.threadId,
                            queue: {
                                position: s.payload.properties.lc2.queue_pos,
                                waitTime: s.payload.properties.lc2.queue_waiting_time,
                            },
                        }),
                    void r('thread_properties_updated', s.payload)
                );
            case W:
                return void ((e, t, n) => {
                    E(n).setItem(gi(e), JSON.stringify(t)).catch(a);
                })(i, s.payload.customer_side_storage, n);
            case F:
                switch (s.payload.reason) {
                    case 'access_token_expired':
                        i.dispatch(Mr(!0)), i.dispatch(Lr(100)), r('disconnected', s.payload);
                        break;
                    case Jr:
                    case 'customer_temporarily_blocked':
                    case 'license_not_found':
                    case Xr:
                    case 'too_many_connections':
                    case 'unsupported_version':
                    case Yr:
                        i.dispatch(jr(s.payload.reason));
                        break;
                    case 'misdirected_connection':
                        mi(i, Rr),
                            i.dispatch({
                                type: lr,
                                payload: s.payload.data,
                            });
                        break;
                    case 'service_temporarily_unavailable':
                    case 'too_many_unauthorized_connections':
                        mi(i, s.payload.reason.toUpperCase());
                        break;
                    default:
                        i.dispatch(Lr(100)), r('disconnected', s.payload);
                }
                return;
            case H: {
                const [e] = s.payload.groups;
                return void r('availability_updated', {
                    availability: Q(e.status),
                });
            }
            case M:
                return ki(r, s.payload.chat.users), void r(s.action, s.payload);
            case N:
                if (null === s.payload.event) return;
                return void r(s.action, s.payload);
            case B:
            case V:
            case R:
                return void r(s.action, s.payload);
            case G:
                return ki(r, [s.payload.user]), void r(s.action, s.payload);
            default:
                return void r(s.action, s.payload);
        }
    },
    Pi = (e, t) => {
        let { emit: n } = e,
            { payload: a } = t;
        switch (a.action) {
            case L:
                return void a.resolve(D);
            case z:
                return ki(n, a.payload.users), void a.resolve(a.payload);
            case M:
                return ki(n, a.payload.chat.users), void a.resolve(a.payload);
            case N:
                return void a.resolve(a.payload.event);
            case x:
                return ki(n, a.payload.users), void a.resolve(a.payload);
            default:
                return void a.resolve(a.payload);
        }
    },
    Oi = e => {
        let { auth: t, customerDataProvider: n, emitter: r, socket: i, licenseId: s, parentStorage: o } = e;
        const { emit: c } = r,
            d = Ii(t, n, 0, o);
        return (e, n) => {
            switch (e.type) {
                case lr:
                    return void i.reinitialize();
                case pr:
                    return void ((e, t, n) =>
                        t.getToken().then(t => {
                            const a = e.getState();
                            null === ni(a) && e.dispatch(Dr(t.entityId));
                            const { page: r } = a;
                            if (!r || !r.url) return;
                            const i = Ha(
                                    fi(
                                        {
                                            organization_id: a.organizationId,
                                        },
                                        ii(a)
                                    )
                                ),
                                s = {
                                    session_fields: cr(n || {}),
                                    group_id: a.groupId || 0,
                                    page_url: r.url,
                                };
                            return k(si(a) + '/action/' + A + '?' + i, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    Authorization: t.tokenType + ' ' + t.accessToken,
                                },
                                body: JSON.stringify(s),
                            }).then(() => {});
                        }))(n, t, e.payload.sessionFields).catch(a);
                case ur: {
                    const { payload: t } = e;
                    switch ((d.cancel(), i.destroy(), t.reason)) {
                        case 'manual':
                            mi(n, Br);
                            break;
                        case Jr:
                        case 'license_expired':
                        case Xr:
                        case Yr:
                            mi(n, Gr), c('disconnected', t);
                            break;
                        default:
                            c('disconnected', t);
                    }
                    return void r.off();
                }
                case gr: {
                    const { reason: t, rejects: n } = e.payload,
                        a = {
                            message: Ti[t],
                            code: t,
                        };
                    return void n.forEach(e => {
                        e(Zr(a));
                    });
                }
                case hr: {
                    const { dynamicConfig: t, customer: n, chats: a, greeting: r, availability: i } = e.payload,
                        s = wi(
                            {
                                customer: n,
                                availability: i,
                            },
                            r && {
                                greeting: r,
                            }
                        );
                    return (
                        Object.defineProperty(s, '__unsafeDynamicConfig', {
                            value: t,
                        }),
                        Object.defineProperty(s, '__unsafeChats', {
                            value: a,
                        }),
                        void c('connected', s)
                    );
                }
                case mr: {
                    const { payload: t } = e;
                    return i.disconnect(), void ('manual' !== t.reason && c('disconnected', t));
                }
                case vr:
                    return e.payload.fresh
                        ? void t.getFreshToken().catch(a)
                        : void t
                              .hasToken()
                              .then(e =>
                                  e
                                      ? t.getToken().then(e => {
                                            let { creationDate: n, expiresIn: a } = e;
                                            if (!(n + a - Date.now() > 36e5))
                                                return t.invalidate().then(t.getFreshToken);
                                        })
                                      : t.getToken()
                              )
                              .catch(a);
                case fr:
                    return (
                        e.payload.action === F || Ei(n, e),
                        void Ai(
                            {
                                emit: c,
                                store: n,
                            },
                            e,
                            o
                        )
                    );
                case yr:
                    return (
                        Ei(n, e),
                        void Pi(
                            {
                                emit: c,
                            },
                            e
                        )
                    );
                case _r:
                    return mi(n, Gr), void i.reconnect(e.payload.delay);
                case Ir: {
                    const { reject: t, error: n } = e.payload;
                    return void t(Zr(n));
                }
                case Sr:
                    return (
                        Ei(n, e),
                        void Pi(
                            {
                                emit: c,
                            },
                            e
                        )
                    );
                case br:
                    {
                        const t = n.getState();
                        if ((e => ei(e) === Qr)(t))
                            return void vi(n, e, {
                                code: Br,
                                message: 'SDK destroyed.',
                            });
                        if (!ri(t) && 'login' !== e.payload.source)
                            return void vi(n, e, {
                                code: 'NO_CONNECTION',
                                message: 'No connection.',
                            });
                        ((e, t) => {
                            let {
                                payload: { id: n, request: a },
                            } = t;
                            const r = wi(
                                {
                                    request_id: n,
                                },
                                a
                            );
                            if (r.action === O) {
                                const t = {
                                    3.6: U(j).filter(e => e !== F),
                                };
                                return void e.emit(
                                    wi({}, r, {
                                        version: '3.6',
                                        payload: wi({}, r.payload, {
                                            pushes: t,
                                        }),
                                    })
                                );
                            }
                            e.emit(r);
                        })(i, e);
                    }
                    return;
                case wr:
                    return void c('customer_id', e.payload.id);
                case Er:
                    return void c('disconnected', {
                        reason: 'connection_lost',
                    });
                case Tr:
                    return void d.sendLogin(n);
                case kr:
                    if (!ri(n.getState())) return;
                    return void c('connection_recovered');
                case Ar:
                    if (!ri(n.getState())) return;
                    return void c('connection_unstable');
                case Pr:
                    return i.connect(), void n.dispatch(Mr());
                case Or:
                    if (!ri(n.getState())) return;
                    return void ui(n, Nr(q, e.payload)).catch(a);
                case Fr:
                    return void c('identity_changed', e.payload);
                default:
                    return;
            }
        };
    },
    qi = function (e, t) {
        let { query: n = {} } = void 0 === t ? {} : t;
        const a = Ha(n),
            r = a ? e + '?' + a : e,
            s = i(),
            o = ga({
                min: 1e3,
                max: 5e3,
                jitter: 0.5,
            });
        let c,
            d = 3,
            l = null;
        const p = () => {
                (d = 1), o.reset(), s.emit('connect');
            },
            u = () => {
                h(), v(), s.emit('disconnect');
            },
            g = e => {
                let { data: t } = e;
                s.emit('message', t);
            },
            h = () => {
                var e;
                (clearTimeout(c), (d = 3), l) &&
                    ((e = l).removeEventListener('open', p),
                    e.removeEventListener('close', u),
                    e.removeEventListener('message', g),
                    l.close(),
                    (l = null));
            },
            m = () => {
                var e;
                (d = 0),
                    (l = new WebSocket(r)),
                    (e = l).addEventListener('open', p),
                    e.addEventListener('close', u),
                    e.addEventListener('message', g);
            },
            v = function (e) {
                void 0 === e && (e = o.duration()), h(), 0 !== e ? (c = setTimeout(m, e)) : m();
            };
        return {
            connect() {
                if (3 !== d) throw new Error('Socket is already open or connecting.');
                clearTimeout(c), m();
            },
            destroy() {
                s.off(), h();
            },
            disconnect: h,
            reconnect: v,
            emit(e) {
                if (1 !== d) throw new Error('Socket is not connected.');
                l.send(e);
            },
            getReadyState: () => d,
            on: s.on,
            off: s.off,
        };
    };

function Fi() {
    return (
        (Fi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        Fi.apply(null, arguments)
    );
}
const Ui = function (e, t) {
    let { query: n = {}, emitter: r = i() } = void 0 === t ? {} : t;
    const s = qi(e, {
            query: n,
        }),
        o = (() => {
            let e,
                t = a;
            return {
                cancel: () => {
                    clearTimeout(e), (t = a);
                },
                check() {
                    const n = T();
                    return (
                        (t = n.resolve),
                        (e = setTimeout(() => {
                            const e = new Error('Timeout.');
                            (e.code = 'TIMEOUT'), n.reject(e);
                        }, 2e3)),
                        n.promise
                    );
                },
                resolve() {
                    clearTimeout(e), t();
                },
            };
        })(),
        c = () => 1 === s.getReadyState(),
        d = () => {
            o.cancel();
        };
    var l, p;
    return (
        (l = s),
        (p = r),
        ['connect', 'disconnect'].forEach(e => {
            l.on(e, t => {
                p.emit(e, t);
            });
        }),
        s.on('disconnect', d),
        s.on('message', e => {
            o.resolve();
            const t = JSON.parse(e);
            r.emit('message', t);
        }),
        'undefined' != typeof window &&
            void 0 !== window.addEventListener &&
            (window.addEventListener('online', () => {
                c() &&
                    o.check().then(
                        () => {
                            o.cancel(), r.emit('connection_recovered');
                        },
                        e => {
                            if ((o.cancel(), 'TIMEOUT' !== e.code)) throw e;
                            s.reconnect();
                        }
                    );
            }),
            window.addEventListener('offline', () => {
                o.cancel(), c() && r.emit('connection_unstable');
            })),
        Fi({}, s, {
            destroy() {
                d(), s.destroy();
            },
            disconnect() {
                d(), s.disconnect();
            },
            reconnect(e) {
                d(), s.reconnect(e);
            },
            emit: e => {
                s.emit(JSON.stringify(e));
            },
            on: r.on,
            off: r.off,
        })
    );
};

function ji() {
    return (
        (ji = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        ji.apply(null, arguments)
    );
}
const xi = (e, t) => {
    const n = e.getState(),
        a = (si(n) + '/rtm/ws').replace(/^https/, 'wss');
    return Ui(a, {
        query: ji(
            {
                organization_id: n.organizationId,
            },
            ii(n)
        ),
        emitter: t,
    });
};

function Mi() {
    return (
        (Mi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        Mi.apply(null, arguments)
    );
}
const Li = (e, t) => {
        const { dispatch: n } = e;
        return (
            t.on('connect', () => {
                n({
                    type: Tr,
                });
            }),
            t.on('message', t => {
                if ('response' === t.type) {
                    if (!t.success)
                        return void ((e, t) => {
                            let { dispatch: n, getState: a } = e;
                            const { request_id: r, payload: i } = t,
                                { reject: s } = ti(a(), r);
                            n({
                                type: Ir,
                                payload: {
                                    id: r,
                                    reject: s,
                                    error: K(i.error),
                                },
                            });
                        })(e, t);
                    switch (t.action) {
                        case Z:
                        case I:
                        case Y:
                            return;
                        default:
                            return void ((e, t) => {
                                let { dispatch: n, getState: a } = e;
                                const { request_id: r } = t,
                                    { promise: i, resolve: s, request: o } = ti(a(), r),
                                    c = $({
                                        request: o,
                                        response: t,
                                    });
                                n({
                                    type: Sr,
                                    payload: Mi(
                                        {
                                            id: r,
                                            promise: i,
                                            resolve: s,
                                        },
                                        c
                                    ),
                                });
                            })(e, t);
                    }
                }
                if ('request_id' in t)
                    switch (t.action) {
                        case M:
                        case N:
                            return void ((e, t) => {
                                let { dispatch: n, getState: a } = e;
                                const { request_id: r } = t,
                                    { promise: i, resolve: s } = ti(a(), r),
                                    o = ee(t);
                                n({
                                    type: yr,
                                    payload: Mi(
                                        {
                                            id: r,
                                            promise: i,
                                            resolve: s,
                                        },
                                        o
                                    ),
                                });
                            })(e, t);
                    }
                ((e, t) => {
                    const n = ee(t);
                    n &&
                        e.dispatch({
                            type: fr,
                            payload: n,
                        });
                })(e, t);
            }),
            t.on('disconnect', () => {
                mi(e, Gr),
                    ei(e.getState()) === Hr &&
                        e.dispatch({
                            type: Er,
                        });
            }),
            t.on('connection_unstable', () => {
                n({
                    type: Ar,
                });
            }),
            t.on('connection_recovered', () => {
                n({
                    type: kr,
                });
            }),
            t.off
        );
    },
    Ni = 'UPLOAD_FAILED',
    zi = function (e, t, n) {
        let { headers: a, method: r = 'POST', onProgress: i, withCredentials: s = !1 } = void 0 === n ? {} : n;
        const o = new XMLHttpRequest();
        return {
            promise: new Promise((n, c) => {
                'function' == typeof i &&
                    (o.upload.onprogress = e => {
                        i(e.loaded / e.total);
                    }),
                    (o.onload = () => {
                        let e;
                        try {
                            e = JSON.parse(o.response);
                        } catch (a) {
                            e = o.response;
                        }
                        if (o.status >= 200 && o.status < 300) return void n(e);
                        const t = new Error('Upload failed.');
                        (t.code = Ni), (t.response = e), c(t);
                    }),
                    (o.onerror = () => {
                        const e = new Error('Upload failed.');
                        (e.code = Ni), c(e);
                    }),
                    (o.onabort = () => {
                        const e = new Error('Upload canceled.');
                        (e.code = 'UPLOAD_CANCELED'), c(e);
                    }),
                    o.open(r, e),
                    (o.withCredentials = s),
                    a && Object.keys(a).forEach(e => o.setRequestHeader(e, a[e])),
                    o.send(
                        (e => {
                            const t = new FormData();
                            return Object.keys(e).forEach(n => t.append(n, e[n])), t;
                        })(t)
                    );
            }),
            cancel() {
                o.abort();
            },
        };
    },
    Di = 10485760,
    Gi = function (e, t) {
        void 0 === t && (t = 2);
        return (e / 1024 / 1024).toFixed(t) + ' MB';
    };

function Ri() {
    return (
        (Ri = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        Ri.apply(null, arguments)
    );
}
const Vi = (e, t) => {
        let n,
            { auth: a, store: r } = e,
            { file: i, onProgress: s } = t,
            o = !1;
        return {
            promise: new Promise((e, t) => {
                (e => {
                    if (e.size > Di)
                        throw Zr({
                            message: 'The file is too big (max size is ' + Gi(Di) + ').',
                            code: 'TOO_BIG_FILE',
                        });
                })(i);
                const c = r.getState(),
                    d = Ha(
                        Ri(
                            {
                                organization_id: c.organizationId,
                            },
                            ii(c)
                        )
                    ),
                    l = si(c) + '/action/' + te + '?' + d,
                    p = {
                        file: i,
                    };
                a.getToken().then(a => {
                    o
                        ? t(new Error('Upload cancelled.'))
                        : ((n = zi(l, p, {
                              headers: {
                                  Authorization: a.tokenType + ' ' + a.accessToken,
                              },
                              onProgress: s,
                          })),
                          n.promise.then(e, e => {
                              if (!e.response) return void t(e);
                              const { type: n, message: a } = e.response.error;
                              t(
                                  Zr({
                                      message: a,
                                      code: n.toUpperCase(),
                                  })
                              );
                          }));
                });
            }),
            cancel() {
                o || ((o = !0), n && n.cancel());
            },
        };
    },
    Bi = ['autoConnect', 'customerDataProvider', 'identityProvider', 'parentStorage'];

function Hi() {
    return (
        (Hi = Object.assign
            ? Object.assign.bind()
            : function (e) {
                  for (var t = 1; t < arguments.length; t++) {
                      var n = arguments[t];
                      for (var a in n) ({}).hasOwnProperty.call(n, a) && (e[a] = n[a]);
                  }
                  return e;
              }),
        Hi.apply(null, arguments)
    );
}
const Qi = function (e, t, n) {
        fa(e);
        const { autoConnect: r = !0, customerDataProvider: s, identityProvider: o, parentStorage: c } = e,
            d = (function (e, t) {
                if (null == e) return {};
                var n = {};
                for (var a in e)
                    if ({}.hasOwnProperty.call(e, a)) {
                        if (-1 !== t.indexOf(a)) continue;
                        n[a] = e[a];
                    }
                return n;
            })(e, Bi),
            l = di(
                Hi({}, d, {
                    env: t,
                })
            ),
            p = i(),
            u = (e => {
                const t = i();
                let n = xi(e, t);
                return ji(
                    {},
                    Object.keys(n).reduce(
                        (e, t) => (
                            (e[t] = function () {
                                return n[t](...arguments);
                            }),
                            e
                        ),
                        {}
                    ),
                    {
                        reinitialize() {
                            n.disconnect(), (n = xi(e, t)), n.connect();
                        },
                    }
                );
            })(l),
            h = 'function' == typeof o ? o() : ya(d, t, c);
        l.addSideEffectsHandler(
            Oi({
                emitter: p,
                socket: u,
                auth: h,
                customerDataProvider: s,
                licenseId: n,
                parentStorage: c,
            })
        ),
            Li(l, u);
        const m = ui.bind(null, l),
            v = () => {
                l.dispatch({
                    type: Pr,
                });
            },
            f = Object.freeze({
                acceptGreeting(e) {
                    let { greetingId: t, uniqueId: n } = e;
                    return m(
                        Nr(Se, {
                            greeting_id: t,
                            unique_id: n,
                        })
                    );
                },
                auth: h,
                cancelGreeting(e) {
                    let { uniqueId: t } = e;
                    return m(
                        Nr(Ie, {
                            unique_id: t,
                        })
                    );
                },
                cancelRate(e) {
                    const { chatId: t, properties: n = ['score'] } = e;
                    return f
                        .listThreads({
                            chatId: t,
                        })
                        .then(e => {
                            let { threads: a } = e;
                            if (!a.length)
                                throw Zr({
                                    message: 'There is no thread in "' + t + '".',
                                    code: Vr,
                                });
                            return f.deleteThreadProperties({
                                chatId: t,
                                threadId: a[0].id,
                                properties: {
                                    rating: n,
                                },
                            });
                        });
                },
                connect: v,
                deactivateChat(e) {
                    let { id: t } = e;
                    return m(
                        Nr(_e, {
                            id: t,
                        })
                    );
                },
                deleteChatProperties(e) {
                    let { id: t, properties: n } = e;
                    return m(
                        Nr(ye, {
                            id: t,
                            properties: n,
                        })
                    );
                },
                deleteEventProperties(e) {
                    let { chatId: t, threadId: n, eventId: a, properties: r } = e;
                    return m(
                        Nr(fe, {
                            chat_id: t,
                            thread_id: n,
                            event_id: a,
                            properties: r,
                        })
                    );
                },
                deleteThreadProperties(e) {
                    let { chatId: t, threadId: n, properties: a } = e;
                    return m(
                        Nr(ve, {
                            chat_id: t,
                            thread_id: n,
                            properties: a,
                        })
                    );
                },
                destroy() {
                    l.dispatch(jr('manual'));
                },
                disconnect() {
                    l.dispatch(xr('manual'));
                },
                getChat(e) {
                    let { chatId: t, threadId: n } = e;
                    return m(
                        Nr(z, {
                            chat_id: t,
                            thread_id: n,
                        })
                    );
                },
                getChatHistory(e) {
                    let { chatId: t } = e;
                    return ((e, t) => {
                        const n = {
                                status: 'idle',
                                queuedTasks: [],
                                nextPageId: null,
                            },
                            a = (r, i) => {
                                switch (n.status) {
                                    case 'idle':
                                        return (
                                            (n.status = 'fetching'),
                                            void e
                                                .listThreads(
                                                    n.nextPageId
                                                        ? {
                                                              chatId: t,
                                                              pageId: n.nextPageId,
                                                          }
                                                        : {
                                                              chatId: t,
                                                              minEventsCount: 25,
                                                          }
                                                )
                                                .then(
                                                    e => {
                                                        let { threads: t, nextPageId: i } = e;
                                                        (n.nextPageId = i),
                                                            n.nextPageId
                                                                ? ((n.status = 'idle'),
                                                                  r({
                                                                      value: {
                                                                          threads: [...t].reverse(),
                                                                      },
                                                                      done: !1,
                                                                  }))
                                                                : ((n.status = 'done'),
                                                                  r({
                                                                      value: {
                                                                          threads: [...t].reverse(),
                                                                      },
                                                                      done: !0,
                                                                  }));
                                                        const s = n.queuedTasks.shift();
                                                        s && a(s.resolve, s.reject);
                                                    },
                                                    e => {
                                                        const { queuedTasks: t } = n;
                                                        (n.status = 'idle'),
                                                            (n.queuedTasks = []),
                                                            i(e),
                                                            t.forEach(t => t.reject(e));
                                                    }
                                                )
                                        );
                                    case 'fetching':
                                        return void n.queuedTasks.push({
                                            resolve: r,
                                            reject: i,
                                        });
                                    case 'done':
                                        return void r({
                                            value: void 0,
                                            done: !0,
                                        });
                                }
                            };
                        return {
                            next: () => new Promise(a),
                        };
                    })(f, t);
                },
                getCustomer: () => m(Nr(me, {})),
                getForm(e) {
                    let { groupId: t, type: n } = e;
                    return m(
                        Nr(he, {
                            group_id: t,
                            type: n,
                        })
                    );
                },
                getUrlInfo(e) {
                    let { url: t } = e;
                    return m(
                        Nr(ge, {
                            url: t,
                        })
                    );
                },
                listChats: e => (
                    void 0 === e && (e = {}),
                    'limit' in e && 'number' == typeof e.limit && e.limit > 25
                        ? Promise.reject(new Error('Specified limit is too high (max 25).'))
                        : m(
                              Nr(
                                  x,
                                  void 0 === e.pageId
                                      ? {
                                            limit: e.limit || 10,
                                        }
                                      : {
                                            page_id: e.pageId,
                                        }
                              )
                          )
                ),
                listGroupStatuses(e) {
                    let { groupIds: t } = void 0 === e ? {} : e;
                    return m(
                        Nr(
                            ue,
                            t
                                ? {
                                      group_ids: t,
                                  }
                                : {
                                      all: !0,
                                  }
                        )
                    );
                },
                listThreads: e =>
                    m(
                        Nr(
                            re,
                            void 0 === e.pageId
                                ? {
                                      chat_id: e.chatId,
                                      sort_order: e.sortOrder,
                                      limit: e.limit,
                                      min_events_count: e.minEventsCount,
                                  }
                                : {
                                      chat_id: e.chatId,
                                      page_id: e.pageId,
                                  }
                        )
                    ),
                markEventsAsSeen(e) {
                    let { chatId: t, seenUpTo: n } = e;
                    return m(
                        Nr(pe, {
                            chat_id: t,
                            seen_up_to: n,
                        })
                    );
                },
                on: p.on,
                once: p.once,
                off: p.off,
                rateChat(e) {
                    const { chatId: t, rating: n } = e;
                    return f
                        .listThreads({
                            chatId: t,
                        })
                        .then(e => {
                            let { threads: a } = e;
                            if (!a.length)
                                throw Zr({
                                    message: 'There is no thread in "' + t + '".',
                                    code: Vr,
                                });
                            return f.updateThreadProperties({
                                chatId: t,
                                threadId: a[0].id,
                                properties: {
                                    rating: n,
                                },
                            });
                        });
                },
                requestWelcomeMessage(e) {
                    let { id: t } = void 0 === e ? {} : e;
                    return m(
                        Nr(
                            le,
                            t
                                ? {
                                      id: t,
                                  }
                                : {}
                        )
                    );
                },
                resumeChat: n => (
                    li({
                        env: t,
                        organizationId: e.organizationId,
                        eventName: 'chat_started',
                    }),
                    m(
                        Nr(
                            Z,
                            (e => {
                                const t = or(e);
                                return rr({}, t, {
                                    chat: rr({}, t.chat, {
                                        id: e.chat.id,
                                    }),
                                });
                            })(n)
                        )
                    )
                ),
                sendEvent: e =>
                    m(
                        (e => {
                            let { chatId: t, event: n, attachToLastThread: a } = e;
                            const r = {
                                chat_id: t,
                                event: sr(n),
                            };
                            return a && (r.attach_to_last_thread = !0), Nr(I, r);
                        })(e)
                    ),
                sendGreetingButtonClicked: e =>
                    ((e, t) => {
                        let { auth: n, store: a } = e,
                            { greetingUniqueId: r, buttonId: i } = t;
                        return n.getToken().then(e => {
                            const t = a.getState(),
                                n = Ha(
                                    pi(
                                        {
                                            organization_id: t.organizationId,
                                        },
                                        ii(t)
                                    )
                                ),
                                s = si(t) + '/action/' + C + '?' + n;
                            return fetch(s, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    Authorization: e.tokenType + ' ' + e.accessToken,
                                },
                                body: JSON.stringify({
                                    greeting_unique_id: r,
                                    button_id: i,
                                }),
                                keepalive: !0,
                            }).then(() => {});
                        });
                    })(
                        {
                            auth: h,
                            store: l,
                        },
                        e
                    ),
                sendRichMessagePostback(e) {
                    let { chatId: t, threadId: n, eventId: a, postback: r } = e;
                    return m(
                        Nr(de, {
                            chat_id: t,
                            event_id: a,
                            thread_id: n,
                            postback: r,
                        })
                    );
                },
                setCustomerSessionFields(e) {
                    let { sessionFields: t } = e;
                    return m(
                        Nr(ae, {
                            session_fields: cr(t),
                        })
                    );
                },
                setSneakPeek: e => {
                    let { chatId: t, sneakPeekText: n } = e;
                    const r = l.getState();
                    ai(r, t) &&
                        ri(r) &&
                        m(
                            Nr(ce, {
                                chat_id: t,
                                sneak_peek_text: n,
                            })
                        ).catch(a);
                },
                startChat: n => (
                    void 0 === n && (n = {}),
                    li({
                        env: t,
                        organizationId: e.organizationId,
                        eventName: 'chat_started',
                    }),
                    m(Nr(Y, or(n)))
                ),
                updateChatProperties(e) {
                    let { id: t, properties: n } = e;
                    return m(
                        Nr(oe, {
                            id: t,
                            properties: n,
                        })
                    );
                },
                updateCustomer: e => m(Nr(ne, dr(e))),
                updateCustomerPage(e) {
                    l.dispatch({
                        type: Or,
                        payload: g(['title', 'url'], e),
                    });
                },
                updateEventProperties(e) {
                    let { chatId: t, threadId: n, eventId: a, properties: r } = e;
                    return m(
                        Nr(se, {
                            chat_id: t,
                            event_id: a,
                            thread_id: n,
                            properties: r,
                        })
                    );
                },
                updateThreadProperties(e) {
                    let { chatId: t, threadId: n, properties: a } = e;
                    return m(
                        Nr(ie, {
                            chat_id: t,
                            thread_id: n,
                            properties: a,
                        })
                    );
                },
                uploadFile: e =>
                    Vi(
                        {
                            auth: h,
                            store: l,
                        },
                        e
                    ),
            });
        return (
            r
                ? v()
                : l.dispatch({
                      type: pr,
                      payload: {
                          sessionFields: 'function' == typeof s ? s().sessionFields : {},
                      },
                  }),
            f
        );
    },
    Wi = (e, t) => '@@lc_privacy_policy:' + e + (Ce() && void 0 !== t ? ':' + t : ''),
    Ji = 'CANCEL',
    Xi = 'NOTHING',
    Yi = 'SET',
    Zi = (e, t) =>
        Ja(
            (() => {
                switch (t.code) {
                    case 'TOO_BIG_FILE':
                        return e.localize('cannot_upload_a_file_over_10mb');
                    case 'VALIDATION':
                        return 'No active chat thread' === t.message
                            ? e.localize('closed_chat_upload_failed')
                            : t.message.includes('File type is forbidden')
                              ? e.localize('prohibited_file_type')
                              : e.localize('upload_failed');
                    default:
                        return e.localize('upload_failed');
                }
            })()
        ),
    Ki = e => {
        const {
                properties: { rate: t, rateComment: n, queued: a },
            } = e.getChat(Te),
            r = e.getView('Chat/queue');
        return {
            rate: t,
            rateComment: n,
            queue: a
                ? {
                      position: r.numberInQueue,
                      waitingTime: r.waitingTime,
                  }
                : null,
        };
    },
    $i = e => e.getChat(Te).properties.lastThread,
    es = e => {
        const t = e.getChat(Te).properties.group,
            n = e.getApplicationState('group');
        return 'number' == typeof t ? t : n;
    },
    ts = (e, t) => !!t && -1 !== t.indexOf(e.getApplicationState('group')),
    ns = e => {
        const t = e.getChat(Te);
        return (!t.active || t.properties.queued) && !t.properties.starting && !t.properties.ended;
    },
    as = (e, t, n) => {
        if (t !== Ae(e)) return !1;
        const a = Pe(Te, e);
        return !!a && a.id === n;
    },
    rs = e => 0 === Oe(e).length,
    is = (e, t) => {
        let { active: n, chatId: a, lastThreadId: r, becameInactive: i } = t;
        const { store: s } = e;
        if (Le(s))
            return {
                fetchedHistory: wa(e, a),
            };
        if (i) {
            const t = s.getChat(Te);
            return {
                fetchedThread: Ta(e, {
                    chatId: a,
                    threadId: t.properties.lastThread,
                }),
            };
        }
        return n
            ? {
                  fetchedThread: Ta(e, {
                      chatId: a,
                      threadId: r,
                  }),
              }
            : void 0;
    },
    ss = ['events'],
    os = e => {
        'livechat' === e.getApplicationState('defaultWidget') &&
            (De(Te, e) || e.getApplicationState().destroyed) &&
            (Ge(e),
            e.updateView('minimized', {
                hidden: !0,
            }));
    },
    cs = (e, t) => {
        const n = Ki(e),
            a = {};
        if (
            ('rate' in t && n.rate !== t.rate && (a.rate = t.rate),
            'rateComment' in t && n.rateComment !== t.rateComment && (a.rateComment = t.rateComment),
            'timestamp' in t && void 0 !== t.timestamp && (a.timestamp = t.timestamp),
            'queue' in t && !Fe(n.queue, t.queue))
        ) {
            const { queue: n } = t,
                { ended: r } = e.getChat(Te).properties;
            !r && n
                ? ((e, t) => {
                      let { thread: n, numberInQueue: a, waitingTime: r } = t;
                      const i = {
                          active: !0,
                          properties: {
                              queued: !0,
                          },
                      };
                      n && (i.properties.lastThread = n),
                          e.updateChat(Te, i),
                          e.updateView('Chat/queue', {
                              numberInQueue: a,
                              waitingTime: r,
                          });
                  })(e, {
                      numberInQueue: n.position,
                      waitingTime: n.waitingTime,
                  })
                : (a.queued = !1);
        }
        e.updateChat(Te, {
            properties: a,
        });
    },
    ds = function (e, t) {
        let { withSystemMessage: n = !1, reason: a = 'users_limit_reached' } = void 0 === t ? {} : t;
        if (
            (e.setApplicationState({
                limitReached: !0,
                clientLimitExceededLifted: !1,
            }),
            Ke(e),
            n)
        ) {
            const t = yt(e)
                ? "Sorry we couldn't connect you with an agent, but you can still leave us a ticket"
                : "Sorry, but we couldn't connect you with an agent. Try refreshing the page or come back later.";
            _t(e, Te, {
                text: t,
            });
        }
        yt(e) && It(e, a);
    },
    ls = e => {
        De(Te, e) ? Ge(e) : e.getApplicationState('wasActivated') && Re(e, 'hidden') && Ve(e, !0),
            e.setApplicationState({
                readyState: Be,
            });
    },
    ps = e => {
        const { store: t } = e;
        return Oa(e, t.getApplicationState('group')).then(e => {
            e.enabled && (t.updateView('Chat/ticketForm', e.form), It(t, 'groups_offline'));
        });
    },
    us = (e, t) => {
        const { store: n } = e,
            r = ((e, t) => {
                const {
                        properties: { rate: n, rateComment: a },
                    } = e.getChat(Te),
                    r = {
                        comment: Xi,
                        score: Xi,
                    };
                t.rating !== n && (r.score = null === t.rating ? Ji : Yi);
                const i = 'string' == typeof t.rateComment && '' !== t.rateComment;
                return (
                    (a && !i) || (r.score === Ji && a)
                        ? (r.comment = Ji)
                        : !i || (a && t.rateComment === a) || (r.comment = Yi),
                    r
                );
            })(n, t),
            { testGroup: i } = n.getApplicationState();
        if (r.score === Xi && r.comment === Xi) return Promise.resolve(null);
        Tt({
            testGroup: i,
            chatRating: r.score === Ji ? 'canceled' : t.rating,
            chatRatingSource: 'postchat',
        });
        const s = [];
        return (
            r.score === Yi && r.comment === Yi
                ? (s.push(qa(e, t)), Et(n, t.rating), kt(n, t.rateComment))
                : r.score === Ji && r.comment === Ji
                  ? s.push(Fa(e, ['comment', 'score']))
                  : (r.score === Ji
                        ? s.push(Fa(e, ['score']))
                        : r.score === Yi &&
                          (s.push(
                              qa(e, {
                                  rating: t.rating,
                              })
                          ),
                          Et(n, t.rating)),
                    r.comment === Ji
                        ? s.push(Fa(e, ['comment']))
                        : r.comment === Yi &&
                          (s.push(
                              qa(e, {
                                  rateComment: t.rateComment,
                              })
                          ),
                          kt(n, t.rateComment))),
            Promise.all(s.map(e => e.catch(a)))
        );
    },
    gs = e => {
        e.updateView('minimized', {
            hidden: !1,
        });
    },
    hs = e => {
        const { sdk: t, store: n } = e;
        t.destroy(),
            n.setApplicationState({
                destroyed: !0,
            }),
            os(n);
    },
    ms = (e, t) => {
        const { store: n } = e,
            a = mt(n, t);
        if (!a) return;
        'form' !== a.type ||
            a.properties.answered ||
            'ask_for_email' !== a.properties.formId ||
            (Math.random() < 0.01 && vt('ask_for_email_form_received', {}),
            n.hasEvent(Te, ft) && n.removeEvent(Te, ft));
        const r = Oe(n).find(e => e.properties.customId === a.properties.customId);
        r
            ? ((e, t, n) => {
                  const { store: a } = e,
                      r = n.seen;
                  a.updateEvent(Te, n.id, {
                      properties: s({}, n.properties, t.properties, {
                          isPreview: !1,
                      }),
                  }),
                      a.setEventServerId(Te, n.id, t.serverId),
                      r && (Ea.updateLatestSeen(t.timestamp), Ua(e, Ea.getLatestSeen())),
                      Pt(a, t.properties.serverType, n.id);
              })(e, a, r)
            : ct(n, a),
            Re(n, 'minimized') && n.emit('render-minimized');
    },
    vs = (e, t) => {
        const { store: n } = e,
            { id: a, active: r, group: i, thread: s, previousThread: o, agent: c, events: d, properties: l } = t,
            p = !!l.queue;
        if (
            (Aa(e, a),
            d.forEach(e => ct(n, e)),
            dt(n, {
                id: a,
                active: r,
                thread: s,
                previousThread: o,
                group: i,
                queued: p,
                agent: c,
                timestamp: l.timestamp,
            }),
            lt(n))
        ) {
            const { position: e, waitingTime: t } = l.queue;
            n.updateView('Chat/queue', {
                numberInQueue: e,
                waitingTime: t,
            });
        }
    },
    fs = (e, t) =>
        t.filter(t => {
            const n = e.hasEvent(Te, t.id),
                a = !!t.properties.customId && e.hasEvent(Te, t.properties.customId);
            return !(n || a || ('form' === t.type && 'ticket' === t.properties.formType));
        }),
    ys = (e, t) => {
        fs(e, t).forEach(t => ct(e, t));
    },
    _s = (e, t, n) => {
        let { eagerFetchingMode: a, group: r } = t,
            { thread: i, eventsSeenUpToMap: o } = n;
        if (!i) return;
        const { id: c, active: d, agent: l, events: p, properties: u } = i,
            g = e.getChat(Te),
            h = !d && g.active,
            m = e.getLastEvent(Te);
        Je(e, 'postchat') && p.find(e => e.properties.answered && e.properties.formId === m.properties.formId) && st(e),
            e.updateChat(Te, {
                active: d,
                properties: s(
                    {
                        ended: g.properties.ended,
                        lastThread: c,
                        group: r,
                        eventsSeenUpToMap: o,
                    },
                    h && {
                        ended: !0,
                        queued: !1,
                        agentActivity: null,
                    }
                ),
            }),
            d && ot(e, l),
            cs(
                e,
                s(
                    {
                        rate: null,
                    },
                    u,
                    {
                        queue: d && 'queue' in u ? u.queue : null,
                    },
                    !a &&
                        !d && {
                            rate: null,
                            rateComment: null,
                        }
                )
            ),
            ys(e, p);
    },
    Is = (e, t) => {
        null === et(e, Te) &&
            e.updateChat(Te, {
                properties: {
                    hasMoreHistory: t,
                },
            });
    },
    Ss = e => {
        var t;
        null == (t = Ea.getHistoryIterator()) ||
            t.next().then(
                t => {
                    let { value: n, done: a } = t;
                    const r = e.getTimeline(Te).length,
                        i = n.filter(Boolean),
                        o = fs(
                            e,
                            He(
                                e =>
                                    e.events.map(e =>
                                        s({}, e, {
                                            seen: !0,
                                        })
                                    ),
                                xe(e) ? Qe(e, i) : i
                            )
                        );
                    o.length > 0 && e.addHistoryEvents(Te, o);
                    r !== e.getTimeline(Te).length || a
                        ? e.updateChat(Te, {
                              properties: {
                                  loadingHistory: !1,
                                  hasMoreHistory: !a,
                              },
                          })
                        : Ss(e);
                },
                () => {
                    e.updateChat(Te, {
                        properties: {
                            loadingHistory: !1,
                        },
                    });
                }
            );
    },
    bs = (e, t, n) => {
        let { id: a, timestamp: r, threadId: i } = n;
        Ot(e, t, r),
            e.setEventServerId(Te, t.id, a),
            e.updateEvent(Te, t.id, {
                delivered: !0,
                serverTimestamp: r,
                thread: i,
            });
    },
    Cs = (e, t) => {
        e.updateEvent(Te, t.id, {
            failed: !0,
        });
    },
    ws = (e, t) => {
        let { event: n, meta: r } = t;
        const { sdk: i, store: s } = e;
        if ('file' === n.type) {
            const e = i.uploadFile({
                file: r.file,
                onProgress: e =>
                    s.updateEvent(Te, n.id, {
                        properties: {
                            progress: e,
                        },
                    }),
            });
            return (
                Ea.setUploadInProgress(n.id, e),
                e.promise
                    .then(
                        e => {
                            let { url: t } = e;
                            s.updateEvent(Te, n.id, {
                                properties: {
                                    serverUrl: t,
                                    finished: !0,
                                },
                            });
                        },
                        e => {
                            'UPLOAD_CANCELED' !== e.code &&
                                s.updateEvent(Te, n.id, {
                                    properties: {
                                        failed: !0,
                                        failReason: Zi(s, e),
                                    },
                                });
                        }
                    )
                    .finally(() => {
                        Ea.removeUploadInProgress(n.id);
                    })
            );
        }
        if (Ct(n.type, ['message', 'emoji']))
            return i
                .sendEvent({
                    chatId: Ae(s),
                    event: wt(s, n),
                })
                .then(
                    e => {
                        bs(s, n, e);
                    },
                    () => {
                        Cs(s, n);
                    }
                );
        if ('custom_system_message' === n.type)
            return i
                .sendEvent({
                    chatId: Ae(s),
                    event: wt(s, n),
                })
                .then(t => ms(e, t), a);
        if ('rich_message_postback' === n.type) {
            const { eventId: e, postback: t } = n.properties;
            return i
                .sendRichMessagePostback({
                    chatId: Ae(s),
                    threadId: s.getEvent(Te, e).thread,
                    eventId: e,
                    postback: t,
                })
                .catch(a);
        }
        if ('url_preview' === n.type) {
            const e = i
                .getUrlInfo({
                    url: n.properties.url,
                })
                .catch(() => null);
            return i
                .sendEvent({
                    chatId: Ae(s),
                    event: wt(s, n),
                })
                .then(
                    t => {
                        bs(s, n, t),
                            e
                                .then(e => {
                                    const { title: a, description: r, url: o, imageUrl: c } = e;
                                    return (
                                        s.updateEvent(Te, n.id, {
                                            properties: {
                                                title: a,
                                                description: r,
                                                image: {
                                                    url: c,
                                                    link: o,
                                                },
                                            },
                                        }),
                                        i.updateEventProperties({
                                            chatId: Ae(s),
                                            threadId: t.thread,
                                            eventId: t.id,
                                            properties: {
                                                url_details: {
                                                    title: a,
                                                    description: r,
                                                    url: o,
                                                    image_url: c,
                                                    image_width: null == e ? void 0 : e.imageWidth,
                                                    image_height: null == e ? void 0 : e.imageHeight,
                                                },
                                            },
                                        })
                                    );
                                })
                                .catch(a);
                    },
                    () => {
                        Cs(s, n);
                    }
                );
        }
    },
    Ts = (e, t) => {
        let { events: n } = t,
            a = o(t, ss);
        const { store: r } = e,
            i = r.getSessionUser().id;
        n.forEach(e => {
            r.getEvent(Te, e.id)
                ? e.author === i
                    ? ((e, t) => {
                          const n = t.timestamp;
                          'message' === t.properties.serverType && Ot(e, t, n),
                              e.setEventServerId(Te, t.id, t.serverId);
                          const a = {
                              delivered: !0,
                              serverTimestamp: n,
                              thread: t.thread,
                          };
                          'form' === t.type &&
                              (a.properties = {
                                  answered: !0,
                                  fields: t.properties.fields,
                              }),
                              e.updateEvent(Te, t.id, a);
                      })(r, e)
                    : e.properties.welcomeMessage || e.properties.invitation
                      ? ((e, t) => {
                            const n = qt(e, Te);
                            e.setEventServerId(Te, n.id, t.serverId);
                            const a = n.author !== t.author;
                            a &&
                                e.setEventData(Te, n.id, {
                                    author: t.author,
                                });
                            const r = {
                                delivered: !0,
                                thread: t.thread,
                                serverTimestamp: t.timestamp,
                                properties: {},
                            };
                            n.properties.text !== t.properties.text && (r.properties.text = t.properties.text),
                                e.updateEvent(Te, n.id, r),
                                a && (ot(e, t.author), e.recalculateTimeline(Te));
                        })(r, e)
                      : ct(r, e)
                : ct(r, e);
        }),
            vs(
                e,
                s({}, a, {
                    events: [],
                })
            );
    },
    Es = (e, t) => {
        const { store: n } = e;
        return (
            n.updateChat(Te, {
                properties: {
                    starting: !0,
                },
            }),
            St(n),
            Pa(e, t).catch(a => {
                if (a.message === bt)
                    return (
                        Ne(n, Te, {
                            forced: !0,
                        }),
                        Es(e, t)
                    );
                throw (
                    (n.updateChat(Te, {
                        properties: {
                            starting: !1,
                        },
                    }),
                    a)
                );
            })
        );
    },
    ks = (e, t) => {
        const { author: n, event: a } = t;
        Ft(e, n);
        const {
            serverId: r,
            properties: { ended: i },
        } = e.getChat(Te);
        i &&
            Ne(e, Te, {
                chatId: r,
            }),
            Ut('hideOnInit', e).enabled &&
                e.setApplicationState({
                    wasActivated: !0,
                });
        const s = qt(e, Te);
        if (s) {
            if (jt(e)) {
                if (Ee(e)) return;
                return void xt(e, s.id).then(() => {
                    Mt(e, a);
                });
            }
            e.removeEvent(Te, s.id);
        }
        Mt(e, a);
    },
    As = e => {
        const { store: t } = e,
            { availability: n, postponedGreeting: a } = t.getApplicationState();
        return 'online' === n && a
            ? Promise.resolve().then(
                  () => (
                      t.setApplicationState({
                          postponedGreeting: null,
                      }),
                      Ea.setPendingAsyncFlow('acceptingGreeting', !0),
                      ja(e, a).then(
                          e => {
                              Ea.setPendingAsyncFlow('acceptingGreeting', !1), ks(t, e);
                          },
                          () => {
                              Ea.setPendingAsyncFlow('acceptingGreeting', !1);
                          }
                      )
                  )
              )
            : Promise.resolve(null);
    },
    Ps = (e, t) => {
        const { store: n } = e;
        if (
            !t.event.properties.isExitIntent &&
            (n.getApplicationState('isExitIntentShadeDisplayed') &&
                (n.setApplicationState({
                    isExitIntentShadeDisplayed: !1,
                }),
                n.emit('remove_exit_intent_shade')),
            !Ea.getIsPendingAsyncFlow('requestingPredictedWelcomeMessage'))
        )
            if (Je(n, 'postchat'))
                n.setApplicationState({
                    postponedGreeting: t,
                });
            else if (Lt(Te, n)) {
                if (!t.event.properties.accepted)
                    return n.getApplicationState('greetingsMuted') && !Re(n, 'maximized')
                        ? (n.updateChat(Te, {
                              properties: {
                                  mutedGreeting: t,
                              },
                          }),
                          void ks(n, t))
                        : (Ea.setPendingAsyncFlow('acceptingGreeting', !0),
                          ja(e, t).then(
                              e => {
                                  Ea.setPendingAsyncFlow('acceptingGreeting', !1), ks(n, e);
                              },
                              () => {
                                  Ea.setPendingAsyncFlow('acceptingGreeting', !1);
                              }
                          ));
                ks(n, t);
            }
    },
    Os = (e, t) => {
        let {
            active: n,
            availability: a,
            connected: i,
            hasFakeAgentMessage: s,
            startChatAgainPending: o,
            limitReached: c,
            hasMutedGreeting: d,
        } = t;
        return r(() => {
            var t;
            const { store: r } = e;
            return c || n
                ? {
                      type: 'nothing',
                  }
                : 'offline' === a
                  ? Xe(r)
                      ? o && Ye(r)
                          ? {
                                type: 'show_prechat',
                            }
                          : {
                                type: 'nothing',
                            }
                      : $e(r)
                        ? zt(r)
                            ? {
                                  type: 'nothing',
                              }
                            : {
                                  type: 'show_ticket_form',
                              }
                        : {
                              type: 'hide_prechat_form',
                          }
                  : d
                    ? {
                          type: 'accept_muted_greeting',
                      }
                    : s
                      ? {
                            type: 'hide_ticket_form',
                        }
                      : Pe(Te, r) && Ye(r)
                        ? {
                              type: 'show_prechat',
                          }
                        : Re(r, 'maximized')
                          ? !i ||
                            Ea.getIsPendingAsyncFlow('acceptingGreeting') ||
                            Ea.getIsPendingAsyncFlow('requestingPredictedWelcomeMessage')
                              ? {
                                    type: 'nothing',
                                }
                              : (Ea.setPendingAsyncFlow('requestingPredictedWelcomeMessage', !0),
                                null == (t = Ea.getLocalizationPromise())
                                    ? void 0
                                    : t
                                          .then(() => xa(e))
                                          .then(
                                              e => {
                                                  let { agent: t, groupHasQueue: n, welcomeMessageId: a } = e;
                                                  a &&
                                                      r.setApplicationState({
                                                          welcomeMessageId: a,
                                                      });
                                                  const i = [
                                                      {
                                                          type: 'hide_ticket_form',
                                                      },
                                                      {
                                                          type: 'predicted_welcome_message',
                                                          payload: {
                                                              agent: t,
                                                              groupHasQueue: n,
                                                          },
                                                      },
                                                  ];
                                                  return (
                                                      Ye(r)
                                                          ? i.push({
                                                                type: 'show_prechat',
                                                            })
                                                          : o &&
                                                            t.isBot &&
                                                            i.push({
                                                                type: 'start_chat',
                                                            }),
                                                      i
                                                  );
                                              },
                                              e => (
                                                  Ea.setPendingAsyncFlow('requestingPredictedWelcomeMessage', !1),
                                                  'offline' === r.getApplicationState('availability') ||
                                                  'GROUP_OFFLINE' === e.code
                                                      ? {
                                                            type: 'nothing',
                                                        }
                                                      : {
                                                            type: 'panic',
                                                        }
                                              )
                                          ))
                          : {
                                type: 'nothing',
                            };
        }).then(Dt);
    },
    qs = (e, t) =>
        t.forEach(t => {
            const { store: n } = e;
            switch (t.type) {
                case 'panic':
                    return void hs(e);
                case 'chat_activated':
                    return void Ts(e, t.payload);
                case 'predicted_welcome_message': {
                    const { agent: e, groupHasQueue: a } = t.payload;
                    return (
                        Ft(n, e),
                        ot(n, e.id),
                        void (
                            Ye(n) ||
                            (Ht(n) ||
                                Gt(n, Te) ||
                                (n.setApplicationState({
                                    disableSendingMessage: !0,
                                }),
                                n.updateChat(Te, {
                                    properties: {
                                        agentActivity: {
                                            type: 'typing',
                                        },
                                        awaitingWelcomeMessage: !0,
                                    },
                                })),
                            n.updateChat(Te, {
                                properties: {
                                    groupHasProbableQueue: a,
                                },
                            }))
                        )
                    );
                }
                case 'show_ticket_form':
                    return t.payload && n.updateView('Chat/ticketForm', t.payload), void It(n, 'offline');
                case 'hide_prechat_form':
                    return void Ke(n);
                case 'hide_ticket_form':
                    return void (Je(n, 'ticket') && Bt(n));
                case 'show_prechat':
                    return void Ze(n);
                case 'accept_muted_greeting':
                    return void (e => {
                        const { store: t } = e,
                            n = t.getLastEvent(Te),
                            { mutedGreeting: r } = t.getChat(Te).properties;
                        t.updateEvent(Te, n.id, {
                            seen: !0,
                        }),
                            Ea.setPendingAsyncFlow('acceptingGreeting', !0),
                            ja(e, r)
                                .then(e => {
                                    let { event: n } = e;
                                    t.updateChat(Te, {
                                        properties: {
                                            mutedGreeting: void 0,
                                        },
                                    }),
                                        Nt(t, n);
                                }, a)
                                .finally(() => {
                                    Ea.setPendingAsyncFlow('acceptingGreeting', !1);
                                });
                    })(e);
                case 'start_chat':
                    return void Vt(n);
                default:
                    return;
            }
        }),
    Fs = e => {
        const t = e.getChat(Te);
        return {
            active: t.active,
            availability: e.getApplicationState('availability'),
            connected: Rt(e),
            hasFakeAgentMessage: Gt(e, Te),
            startChatAgainPending: t.properties.startChatAgainPending,
            limitReached: e.getApplicationState('limitReached'),
            hasMutedGreeting: !!t.properties.mutedGreeting,
        };
    },
    Us = e => {
        const t = Object.keys(e);
        return Promise.all(U(e)).then(e =>
            Qa(
                (function (e, t, n) {
                    return t.map((t, a) => e(t, n[a]));
                })(nr, t, e)
            )
        );
    },
    js = ['queueTemplate', 'chatSummary', 'postchatForm', 'maximizedDecisionActions'],
    xs = (e, t) => ({
        threadPropertiesDeleted: t => {
            let { threadId: n, properties: a } = t;
            n === $i(e) &&
                'rating' in a &&
                Ct('score', a.rating) &&
                cs(
                    e,
                    s({}, Ki(e), {
                        rate: null,
                    })
                );
        },
        threadPropertiesUpdated: t => {
            let { threadId: n, properties: a } = t;
            n === $i(e) && 'rating' in a && cs(e, s({}, Ki(e), mn(a.rating)));
        },
        queuePositionUpdated: t => {
            let { threadId: n, queue: a } = t;
            n === $i(e) &&
                cs(
                    e,
                    s({}, Ki(e), {
                        queue: hn(a),
                    })
                );
        },
        chatTransferred: t => {
            if (!('groupIds' in t.transferredTo)) return;
            const n = t.transferredTo.groupIds[0];
            e.updateChat(Te, {
                properties: {
                    group: n,
                },
            }),
                t.queue &&
                    cs(
                        e,
                        s({}, Ki(e), {
                            queue: hn(t.queue),
                        })
                    );
        },
        customerUpdated: t => {
            const n = e.getSessionUserId();
            e.updateUser(n, g(['name', 'email'], t)),
                t.sessionFields && e.setUserProperties(n, t.sessionFields),
                e.emit('customer_updated');
        },
        eventPropertiesUpdated: t => {
            let { chatId: n, threadId: a, eventId: r, properties: i } = t;
            if (n === Ae(e) && a === $i(e)) {
                if ('translation' in i) {
                    const t = e.getEventByServerId(Te, r);
                    if (!t) return;
                    e.updateEvent(Te, t.id, {
                        properties: {
                            translation: un(i.translation),
                        },
                    });
                }
                if ('bb9e5b2f1ab480e4a715977b7b1b4279' in i) {
                    const t = e.getEventByServerId(Te, r);
                    if (!t) return;
                    const a = i.bb9e5b2f1ab480e4a715977b7b1b4279.message_reaction;
                    e.updateEvent(Te, t.id, {
                        properties: {
                            reaction: a,
                        },
                    }),
                        t.own &&
                            (e.getApplicationState('license') === gn || Math.random() < 0.1) &&
                            vt('message_reaction_received', {
                                reaction: a,
                                messageType: t.type,
                                chatId: n,
                            }),
                        a &&
                            e.emit('reaction_received', {
                                event: t,
                            });
                }
            }
        },
        eventUpdated: t => {
            let { chatId: n, threadId: a, event: r } = t;
            if (n !== Ae(e) || a !== $i(e)) return;
            if (!tn('properties.lc2.welcome_message', r)) return;
            const i = e.getEventByServerId(Te, r.id);
            r.authorId !== i.author &&
                (e.setEventData(Te, i.id, {
                    author: r.authorId,
                }),
                e.recalculateTimeline(Te)),
                i.properties.invitation && 'quick_replies' === i.properties.type && (r.text = r.elements[0].title),
                r.text !== i.properties.text &&
                    e.updateEvent(Te, i.id, {
                        properties: {
                            text: r.text,
                        },
                    });
        },
        disconnected: n => {
            var a;
            let { reason: r } = n;
            switch (r) {
                case 'access_denied':
                case 'too_many_connections':
                    return (
                        At(r),
                        void hs({
                            store: e,
                            sdk: t,
                        })
                    );
                case 'customer_banned':
                case 'license_not_found':
                case 'unsupported_version':
                case 'inactivity_timeout':
                    return void (e.getApplicationState('pageFocused') || (e.setConnectionState(pn), t.disconnect()));
                case 'users_limit_reached':
                    return (
                        ds(e, {
                            withSystemMessage: !1,
                        }),
                        e.setConnectionState(ln),
                        void (
                            null == (a = Ea.getLocalizationPromise()) ||
                            a.then(() => {
                                ls(e);
                            })
                        )
                    );
                default:
                    return (
                        'connection_timeout' === r && Math.random() <= 0.1
                            ? cn('connection_timeout', {})
                            : Math.random() <= 1e-4 &&
                              cn('disconnected', {
                                  reason: r,
                              }),
                        void e.setConnectionState(dn)
                    );
            }
        },
        userAddedToChat: t => {
            let { chatId: n, user: a, present: r } = t;
            if (!r || n !== Ae(e) || e.getSessionUser().serverId === a.id) return;
            const i = Pe(Te, e);
            (i && i.id === a.id) ||
                (cs(
                    e,
                    s({}, Ki(e), {
                        queue: null,
                    })
                ),
                ot(e, a.id));
        },
        userRemovedFromChat: t => {
            let { chatId: n, userId: a, reason: r } = t;
            if (n !== Ae(e)) return;
            e.removeParticipant(Te, a);
            const i = e.getChat(Te).properties.agentActivity;
            if (
                ('thinking' === (null == i ? void 0 : i.type) &&
                    i.authorId === a &&
                    e.updateChat(Te, {
                        properties: {
                            agentActivity: null,
                        },
                    }),
                e.getSessionUser().serverId === a)
            )
                return;
            const s = Pe(Te, e);
            s && s.id === a && 'chat_deactivated' !== r && ot(e, null);
        },
        greetingCanceled: t => {
            let { uniqueId: n } = t;
            const a = e.getEvents(Te),
                r = sn(e => e.properties.uniqueId === n, a);
            r && on(e, r.id);
        },
        eventsMarkedAsSeen: t => {
            let { chatId: n, userId: a, seenUpTo: r } = t;
            if (n !== Ae(e)) return;
            e.updateChat(Te, {
                properties: {
                    eventsSeenUpToMap: s({}, e.getChat(Te).properties.eventsSeenUpToMap, {
                        [a]: r,
                    }),
                },
            });
            const i = new Date(r).getTime();
            (e.getSessionUser().serverId === a ? an : rn)(Te, i, e).forEach(t => {
                e.updateEvent(Te, t.id, {
                    seen: !0,
                });
            });
        },
        incomingEvent: n => {
            let { chatId: a, event: r } = n;
            if (a !== Ae(e)) return;
            e.getChat(Te).properties.lastThread !== r.threadId &&
                e.updateChat(Te, {
                    properties: {
                        lastThread: r.threadId,
                    },
                }),
                'postchat' === tn('properties.lc2.form_type', r) && st(e),
                nn(Te, e) && At('received_event_during_chat_starting'),
                ms(
                    {
                        sdk: t,
                        store: e,
                    },
                    r
                );
        },
        incomingEventPreview: t => {
            let { chatId: n, event: a } = t;
            n === Ae(e) &&
                ((e, t) => {
                    const n = gt(e, t),
                        a = Oe(e).find(e => e.properties.customId === t.customId);
                    if (a)
                        return (
                            e.updateEvent(Te, a.id, {
                                properties: s({}, a.properties, n.properties),
                            }),
                            void ht(e)
                        );
                    We(e, Te, n);
                })(e, a);
        },
        chatDeactivated: n => {
            let { chatId: r } = n;
            r === Ae(e) &&
                (e => {
                    const { store: t } = e;
                    if ((pt(t), !je(t))) {
                        if (xe(t)) {
                            const {
                                properties: { rate: e },
                            } = t.getChat(Te);
                            if (e) return;
                            return void ut(t, Me);
                        }
                        Ca(e, es(t)).then(e => {
                            let { enabled: n, form: a } = e;
                            n && ut(t, a);
                        }, a);
                    }
                })({
                    store: e,
                    sdk: t,
                });
        },
        incomingGreeting: n => {
            if (!Wt(e)) return;
            const a = Jt(e, n);
            Rt(e)
                ? Ps(
                      {
                          sdk: t,
                          store: e,
                      },
                      a
                  )
                : Ea.updateConnectionStateFetcherContext({
                      greeting: a,
                  });
        },
        availabilityUpdated: t => {
            let { availability: n } = t;
            Rt(e)
                ? e.setApplicationState({
                      availability: n,
                  })
                : Ea.updateConnectionStateFetcherContext({
                      availability: n,
                  });
        },
        incomingChat: n => {
            Ne(e, Te, {
                chatId: n.chat.id,
            });
            const a = en(e, n);
            vs(
                {
                    sdk: t,
                    store: e,
                },
                a
            );
        },
        connected: n => {
            let { __unsafeDynamicConfig: a, __unsafeChats: r, greeting: i, availability: c, customer: d } = n;
            const l = Ea.getReportConnectionUnsuccessfulTimerId();
            l && (clearTimeout(l), Ea.setReportConnectionUnsuccessfulTimerId(null));
            const p = {
                    sdk: t,
                    store: e,
                },
                { limitReached: u } = e.getApplicationState();
            u &&
                e.setApplicationState({
                    limitReached: !1,
                });
            const g = ((e, t) => {
                const n = e.getSessionUser(),
                    a = {};
                return (
                    n.name && t.name !== n.name && (a.name = n.name),
                    n.email && t.email !== n.email && (a.email = n.email),
                    qe(n.properties) ||
                        Fe(n.properties, t.sessionFields) ||
                        (a.sessionFields = qe(t.sessionFields)
                            ? n.properties
                            : Qa(
                                  Ue(n.properties).reduce((e, n) => {
                                      let [a, r] = n;
                                      return a in t.sessionFields ? e : [].concat(e, [[a, r]]);
                                  }, [])
                              )),
                    qe(a) ? null : a
                );
            })(e, d);
            let h;
            g &&
                ((e, t) => {
                    let { customerData: n, usedSessionFieldsNumber: a } = t;
                    const r = t => {
                        e.updateCustomer(t).catch(e => At('update_customer_request_failed', e));
                    };
                    n.sessionFields
                        ? Ue(n.sessionFields)
                              .slice(0, at - a)
                              .reduce((e, t) => (qe(e) || rt(e).length >= it ? e.push([t]) : rt(e).push(t), e), [])
                              .map(Qa)
                              .reduce(
                                  (e, t, a) =>
                                      e.then(() =>
                                          r(
                                              s({}, 0 === a && n, {
                                                  sessionFields: t,
                                              })
                                          )
                                      ),
                                  Promise.resolve()
                              )
                        : r(n);
                })(t, {
                    customerData: g,
                    usedSessionFieldsNumber: Xa(d.sessionFields || {}).length,
                }),
                Ft(e, d),
                'boolean' != typeof e.getApplicationState().isReturning &&
                    e.setApplicationState({
                        isReturning: d.statistics.visitsCount > 1,
                    }),
                e.setApplicationState({
                    clientChatNumber: d.statistics.threadsCount || 0,
                    clientVisitNumber: d.statistics.visitsCount || 0,
                    clientLastVisitTimestamp: a.customer_data.last_visit_timestamp,
                    clientPageViewsCount: d.statistics.pageViewsCount || 0,
                }),
                Ea.setConnectionStateFetcherContext({
                    availability: c,
                    greeting: Wt(e) && i && Jt(e, i),
                }),
                Promise.resolve()
                    .then(() => {
                        if (!r.length) return;
                        const [{ id: t, active: n, hasUnreadEvents: i }] = r;
                        Le(e) &&
                            e.setApplicationState({
                                hasUnseenEvents: i,
                            });
                        const s = !n && e.getChat(Te).active;
                        (h = {
                            active: n,
                            chatId: t,
                            becameInactive: s,
                            dynamicConfig: a,
                        }),
                            null === e.getChat(Te).serverId && e.setChatServerId(Te, t);
                        const { eagerFetchingMode: o } = e.getApplicationState();
                        return n || Re(e, 'maximized') || o ? Ma(p) : void 0;
                    })
                    .then(e =>
                        e
                            ? ((h.group = e.group),
                              (h.lastThreadId = e.lastThreadId),
                              h.becameInactive
                                  ? Us(
                                        s(
                                            {
                                                chatSummary: e,
                                            },
                                            ((e, t) => {
                                                let { group: n } = t;
                                                const { store: a } = e;
                                                if (je(a)) return {};
                                                if (xe(a)) {
                                                    const {
                                                        properties: { rate: e },
                                                    } = a.getChat(Te);
                                                    return e
                                                        ? {}
                                                        : {
                                                              postchatForm: Promise.resolve({
                                                                  enabled: !0,
                                                                  form: Me,
                                                              }),
                                                          };
                                                }
                                                const r = Le(a) ? n : es(a);
                                                return {
                                                    postchatForm: Ca(e, r).catch(() => ({
                                                        enabled: !1,
                                                    })),
                                                };
                                            })(p, h),
                                            is(p, h)
                                        )
                                    )
                                  : Us(
                                        s(
                                            {
                                                chatSummary: e,
                                            },
                                            is(p, h)
                                        )
                                    ))
                            : Us({})
                    )
                    .then(t => {
                        const n = !!t.chatSummary && t.chatSummary.active,
                            a = Boolean(
                                Ea.getConnectionStateFetcherContext().greeting &&
                                    !Ea.getConnectionStateFetcherContext().greeting.event.properties.isExitIntent
                            );
                        return n
                            ? t
                            : Us(
                                  s({}, t, {
                                      maximizedDecisionActions: ns(e)
                                          ? Os(p, {
                                                active: !1,
                                                availability: Ea.getConnectionStateFetcherContext().availability,
                                                connected: !0,
                                                hasFakeAgentMessage: Gt(e, Te) || a,
                                            })
                                          : null,
                                  })
                              );
                    })
                    .then(t => {
                        let { queueTemplate: n, chatSummary: a, postchatForm: r, maximizedDecisionActions: i } = t,
                            s = o(t, js);
                        const c = Ea.getConnectionStateFetcherContext();
                        if (
                            (Ea.clearConnectionStateFetcherContext(),
                            n &&
                                e.setLocalization({
                                    user_in_queue: n,
                                }),
                            e.setApplicationState({
                                availability: c.availability,
                            }),
                            !a)
                        )
                            return i && qs(p, i), c.greeting ? Ps(p, c.greeting) : void 0;
                        const d = {
                            chatId: a.id,
                            group: a.group,
                            eagerFetchingMode: e.getApplicationState().eagerFetchingMode,
                        };
                        e.setApplicationState({
                            eagerFetchingMode: !0,
                        });
                        const l = $i(e) && a.lastThreadId !== $i(e);
                        if (Le(e)) {
                            const { fetchedHistory: t } = s;
                            ((e, t) => {
                                const n = e.getChat(Te).properties.lastThread;
                                return (
                                    !!n &&
                                    !t.some(e => {
                                        let { id: t } = e;
                                        return n === t;
                                    })
                                );
                            })(e, t.threads) &&
                                At('threads_gap', null, {
                                    meta: JSON.stringify({
                                        stateLastThreadId: e.getChat(Te).properties.lastThread,
                                        fetchedThreads: t.threads.map(e => {
                                            let { id: t } = e;
                                            return t;
                                        }),
                                    }),
                                }),
                                l &&
                                    Ne(e, Te, {
                                        chatId: e.getChat(Te).serverId,
                                    }),
                                ((e, t, n) => {
                                    const { store: a } = e;
                                    Aa(e, t.chatId, n.iterator), Is(a, n.hasMore);
                                    const r = xe(a) ? Qe(a, n.threads) : n.threads,
                                        [i, [s]] = ((o = -1), [(c = r).slice(0, o), c.slice(o, c.length)]);
                                    var o, c;
                                    ys(
                                        a,
                                        He(e => {
                                            let { events: t } = e;
                                            return t;
                                        }, i)
                                    ),
                                        _s(a, t, {
                                            thread: s,
                                            eventsSeenUpToMap: n.eventsSeenUpToMap,
                                        });
                                })(p, d, t);
                        } else
                            s.fetchedThread &&
                                (l &&
                                    a.active &&
                                    Ne(e, Te, {
                                        chatId: e.getChat(Te).serverId,
                                    }),
                                _s(e, d, s.fetchedThread));
                        if ((i && qs(p, i), !a.active))
                            if (r && r.enabled) ut(e, r.form);
                            else if (c.greeting) return Ps(p, c.greeting);
                    })
                    .then(() => {
                        const t = e.getConnectionState() === Xt;
                        return e.setConnectionState(Yt), os(e), e.getChat(Te).active && Re(e, 'hidden') && Ve(e, !0), t;
                    })
                    .then(t => {
                        const n = e.getChat(Te),
                            { availability: a, readyState: r } = e.getApplicationState();
                        var i;
                        r !== Be &&
                            (null == (i = Ea.getLocalizationPromise()) ||
                                i.then(() => {
                                    ls(e);
                                }));
                        Zt(e) &&
                            (e.setApplicationState({
                                showTextSelectionTracking: !0,
                            }),
                            Kt(
                                e,
                                {
                                    state: 'classic',
                                },
                                {
                                    render: !1,
                                }
                            )),
                            t || !Xe(e) || !Ye(e) || n.active || ('offline' !== a && !n.properties.ended) || Ze(e);
                    })
                    .catch(e => {
                        switch ((Ea.clearConnectionStateFetcherContext(), e.code)) {
                            case 'CONNECTION_LOST':
                                return;
                            case 'REQUEST_TIMEOUT':
                            case 'MISSING_USER':
                                return t.disconnect(), void t.connect();
                            case 'INTERNAL':
                                return void $t('connection_fetcher_internal_error');
                            default:
                                return void At('connection_fetcher_error', e);
                        }
                    });
        },
    }),
    Ms = 'incorrect requester structure',
    Ls = (e, t) => (e.length ? e + '\n' + t : t),
    Ns = (e, t, n) => {
        let { filledForm: a, groupId: r, organizationId: i, timeZone: o, page: c } = t;
        return e.getToken().then(e => {
            var t;
            const d = n.getApplicationState(),
                l = La(d) + '/v2/tickets/new',
                p = (e => {
                    let {
                        fields: t,
                        customerId: n,
                        groupId: a,
                        organizationId: r,
                        timeZone: i,
                        page: o,
                        additionalInfo: c,
                    } = e;
                    const d = s(
                        {
                            organization_id: r,
                            ticket_message: '',
                            offline_message: '',
                            visitor_id: n,
                            requester: {},
                        },
                        'number' == typeof a && {
                            group: a,
                        },
                        o && {
                            source: {
                                url: o,
                            },
                        },
                        i && {
                            timezone: i,
                        },
                        c && {
                            additional_info: {
                                reason: c.lastDisplayedReason,
                                displayed_at: c.lastDisplayedAt,
                            },
                        }
                    );
                    return t.reduce((e, t) => {
                        switch (t.type) {
                            case 'subject': {
                                const n = t.answer,
                                    a = n ? t.label + ' ' + n : t.label;
                                return n && (e.subject = n), (e.offline_message = Ls(e.offline_message, a)), e;
                            }
                            case 'name': {
                                const n = t.answer,
                                    a = n ? t.label + ' ' + n : t.label;
                                return n && (e.requester.name = n), (e.offline_message = Ls(e.offline_message, a)), e;
                            }
                            case 'email': {
                                const n = t.answer,
                                    a = n ? t.label + ' ' + n : t.label;
                                return (e.requester.mail = n), (e.offline_message = Ls(e.offline_message, a)), e;
                            }
                            case 'question':
                            case 'textarea': {
                                const n = t.answer,
                                    a = n ? t.label + ' ' + n : t.label;
                                return (
                                    (e.offline_message = Ls(e.offline_message, a)),
                                    (e.ticket_message = Ls(e.ticket_message, a)),
                                    e
                                );
                            }
                            case 'radio':
                            case 'select': {
                                const n = t.answer && t.answer.label,
                                    a = n ? t.label + ' ' + n : t.label;
                                return (
                                    (e.offline_message = Ls(e.offline_message, a)),
                                    (e.ticket_message = Ls(e.ticket_message, a)),
                                    e
                                );
                            }
                            case 'checkbox': {
                                const n = t.answers && t.answers.map(e => e.label).join(', '),
                                    a = n ? t.label + ' ' + n : t.label;
                                return (
                                    (e.offline_message = Ls(e.offline_message, a)),
                                    (e.ticket_message = Ls(e.ticket_message, a)),
                                    e
                                );
                            }
                            default:
                                return e;
                        }
                    }, d);
                })({
                    fields: a.fields,
                    customerId: e.entityId,
                    groupId: r,
                    organizationId: i,
                    timeZone: o,
                    page: c,
                    additionalInfo: d.config.features.ticketForm.additionalInfo,
                });
            return k(l, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Region': null != (t = d.region) ? t : '',
                },
                body: JSON.stringify(p),
            }).then(e => {
                if (e.ok)
                    return e.json().then(e =>
                        s({}, e, {
                            text: p.ticket_message,
                        })
                    );
                if (400 === e.status || 422 === e.status) {
                    const t = e => {
                        if (!e || !e.errors) throw new Error();
                        const t = e.errors[0];
                        if (Object.keys(t)[0] === Ms) {
                            const e = new Error(t[Ms][0]);
                            throw ((e.code = 'VALIDATION'), e);
                        }
                        throw new Error();
                    };
                    return e.json().then(t, t);
                }
                throw new Error();
            });
        });
    },
    zs = ['properties'],
    Ds = ['properties'],
    Gs = (r, i, g, h) => {
        const m =
                !i.getApplicationState('clientLimitExceeded') ||
                !i.getApplicationState('embedded') ||
                i.getApplicationState('actingAsDirectLink') ||
                i.getApplicationState('isInCustomContainer'),
            v = ((e, t, n) => {
                let {
                    organizationId: a,
                    requestedGroup: r,
                    group: i,
                    region: s,
                    uniqueGroups: o,
                    autoConnect: c,
                    mobile: d,
                    identityProvider: l,
                    parentStorage: p,
                } = t;
                const u = e.getApplicationState('page'),
                    g = {
                        organizationId: a,
                        clientId: 'c5e4f61e1a6c3b1521b541bc5c5a2ac5',
                        mobile: d,
                        region: s,
                        page: P(['url', 'title'], u),
                        referrer: u.referrer,
                        autoConnect: c,
                        application: {
                            channelType: Qt(e),
                        },
                        uniqueGroups: o,
                        identityProvider: l,
                        customerDataProvider: () => {
                            const t = e.getSessionUser(),
                                n = {};
                            return (
                                t.name && (n.name = t.name),
                                t.email && (n.email = t.email),
                                t.properties &&
                                    !qe(t.properties) &&
                                    (n.sessionFields =
                                        Xa(t.properties).length <= it
                                            ? t.properties
                                            : Qa(Ue(t.properties).slice(0, it))),
                                n
                            );
                        },
                        parentStorage: p,
                    };
                return o ? (g.groupId = i) : null !== r && (g.groupId = r), Qi(g, 'production', n);
            })(
                i,
                s({}, r, {
                    autoConnect: m,
                }),
                h
            ),
            f = xs(i, v),
            y = ((e, t) => ({
                requestUpdateChat: n => {
                    let {
                            resolve: a,
                            reject: r,
                            meta: i,
                            data: { properties: s = {} },
                        } = n,
                        c = o(n.data, zs);
                    if (s.rateComment) {
                        const { rateComment: n } = s;
                        kt(e, n),
                            t
                                .rateChat({
                                    chatId: Ae(e),
                                    rating: {
                                        comment: n,
                                    },
                                })
                                .then(a, r);
                    } else if (void 0 !== s.rate) {
                        var d;
                        Et(e, s.rate);
                        const { testGroup: n } = e.getApplicationState();
                        if (
                            (Tt({
                                testGroup: n,
                                chatRating: null === s.rate ? 'canceled' : s.rate,
                                chatRatingSource: (null == i ? void 0 : i.source) || 'other',
                            }),
                            null === s.rate)
                        )
                            return void t
                                .cancelRate({
                                    chatId: Ae(e),
                                })
                                .then(() => {
                                    e.updateChat(Te, {
                                        properties: {
                                            rateComment: null,
                                        },
                                    }),
                                        a();
                                }, r);
                        t.rateChat({
                            chatId: Ae(e),
                            rating: {
                                score: null != (d = Da(s.rate)) ? d : void 0,
                            },
                        }).then(a, r);
                    } else
                        s.transcriptSentTo
                            ? t
                                  .updateThreadProperties({
                                      chatId: Ae(e),
                                      threadId: $i(e),
                                      properties: {
                                          routing: {
                                              transcript_email: s.transcriptSentTo,
                                          },
                                      },
                                  })
                                  .then(a, r)
                            : !1 === c.active &&
                              t
                                  .deactivateChat({
                                      id: Ae(e),
                                  })
                                  .then(a, r);
                },
                requestUpdateEvent: n => {
                    const a = e.getEvent(Te, n.id),
                        r = {
                            store: e,
                            sdk: t,
                        };
                    if (n.data.seen) {
                        const t = a.properties.isPreview;
                        n.resolve(),
                            t || (Ea.updateLatestSeen(e.getEvent(Te, n.id).timestamp), Ua(r, Ea.getLatestSeen()));
                    } else if ('ticket' === a.properties.formType) {
                        const { answers: t } = n.data.properties,
                            { fields: c } = a.properties,
                            { fields: d } = yn(c, t),
                            l = e.getApplicationState();
                        let p = null,
                            u = null,
                            g = null;
                        switch (Ut('ticketForm', e).mode) {
                            case 'helpdesk': {
                                var i;
                                const e = Fn(),
                                    t = In({
                                        hdLicenseID:
                                            null == (i = l.config.properties.license[e]) ? void 0 : i.hdLicenseID,
                                        group: l.group,
                                        pageUrl: l.page.url,
                                        form: ((o = a.properties), Sn(qn(o))),
                                        answers: d,
                                        additionalInfo: l.config.features.ticketForm.additionalInfo,
                                    });
                                (p = bn(r.sdk.auth.getToken, t)), (u = e => jn(e.id, t)), (g = xn);
                                break;
                            }
                            case 'offline_message': {
                                const { filledForm: e } = _n(a, t);
                                (p = Es(r, {
                                    customerStartingEvent: e,
                                    group: l.group,
                                }).then(e => (Ts(r, e), e))),
                                    (u = t => {
                                        var n, a;
                                        const r = Un(e => 'subject' === e.type, e.fields);
                                        return s(
                                            {
                                                id: t.thread,
                                                text: Ga(e),
                                                visitor: {
                                                    name:
                                                        (null == (n = Un(e => 'name' === e.type, e.fields))
                                                            ? void 0
                                                            : n.answer) || null,
                                                    email:
                                                        (null == (a = Un(e => 'email' === e.type, e.fields))
                                                            ? void 0
                                                            : a.answer) || null,
                                                },
                                            },
                                            (null == r ? void 0 : r.answer) && {
                                                subject: r.answer,
                                            }
                                        );
                                    }),
                                    (g = (e, t, n) => {
                                        n();
                                    });
                                break;
                            }
                            default: {
                                const { filledForm: n } = _n(a, t),
                                    { timeZone: i } = new Intl.DateTimeFormat().resolvedOptions();
                                (p = Ns(
                                    r.sdk.auth,
                                    {
                                        filledForm: n,
                                        groupId: l.group,
                                        organizationId: l.organizationId,
                                        timeZone:
                                            'string' != typeof i ||
                                            /^Etc\//.test(i) ||
                                            (-1 === i.indexOf('/') && 'UTC' !== i)
                                                ? null
                                                : i,
                                        page: l.page.url,
                                    },
                                    e
                                )),
                                    (u = e => {
                                        var t, a;
                                        const r = Un(e => 'subject' === e.type, n.fields);
                                        return s(
                                            {
                                                id: e.id,
                                                text: e.text,
                                                visitor: {
                                                    name:
                                                        (null == (t = Un(e => 'name' === e.type, n.fields))
                                                            ? void 0
                                                            : t.answer) || null,
                                                    email:
                                                        (null == (a = Un(e => 'email' === e.type, n.fields))
                                                            ? void 0
                                                            : a.answer) || null,
                                                },
                                            },
                                            (null == r ? void 0 : r.answer) && {
                                                subject: r.answer,
                                            }
                                        );
                                    }),
                                    (g = (e, t, n) => {
                                        e && 'VALIDATION' === e.code
                                            ? /name must be at most \d+ characters long/.test(e.message)
                                                ? n({
                                                      name: e.message,
                                                  })
                                                : 'mail must be a valid e-mail address' !== e.message
                                                  ? n()
                                                  : n({
                                                        email: t('invalid_email'),
                                                    })
                                            : n();
                                    });
                                break;
                            }
                        }
                        p.then(
                            t => {
                                const { fields: r } = a.properties;
                                Cn(e, r, d, null == u ? void 0 : u(t)), n.resolve(), wn(e, n.id, void 0);
                            },
                            t => {
                                null == g || g(t, e.localize, n.reject);
                            }
                        );
                    } else if ('prechat' === a.properties.formType) {
                        const { answers: t } = n.data.properties,
                            { fields: i } = a.properties;
                        Tn(e, i, yn(i, t).fields);
                        const { filledForm: s, choosenGroup: o } = _n(a, t),
                            c = t => {
                                switch (t.code) {
                                    case 'SERVICE_UNAVAILABLE':
                                        return void ds(e, {
                                            withSystemMessage: !0,
                                            reason: 'service_unavailable',
                                        });
                                    case 'GROUPS_OFFLINE':
                                        return void ps(r).then(n.resolve, n.reject);
                                    case 'CUSTOMER_BANNED':
                                    case 'GROUP_NOT_FOUND':
                                        return void hs(r);
                                    default:
                                        n.reject();
                                }
                            },
                            d = () =>
                                Es(r, {
                                    customerStartingEvent: s,
                                    agentFakeEvent: qt(e, Te),
                                    group: o,
                                })
                                    .then(e => {
                                        Ts(r, e);
                                    })
                                    .catch(e => c(e));
                        if (void 0 !== o)
                            return void Na(r, {
                                groupId: o,
                            })
                                .then(e => {
                                    if ('not_found' === e) {
                                        const e = new Error(
                                            'Group "' + o + '" not found (most likely it has been removed).'
                                        );
                                        throw ((e.code = 'GROUP_NOT_FOUND'), e);
                                    }
                                    return e;
                                })
                                .then(
                                    t => {
                                        const a = e.getApplicationState().group;
                                        if (
                                            (e.setApplicationState({
                                                group: o,
                                            }),
                                            'online' !== t)
                                        )
                                            return Xe(e)
                                                ? void d().then(() => {
                                                      e.setApplicationState({
                                                          availability: 'offline',
                                                      });
                                                  }, c)
                                                : void Promise.all(
                                                      [
                                                          Oa(r, o),
                                                          a !== o &&
                                                              za(r, {
                                                                  groupId: o,
                                                              }),
                                                      ].filter(Boolean)
                                                  ).then(
                                                      t => {
                                                          let [n, a] = t;
                                                          n.enabled
                                                              ? (kn(
                                                                    e,
                                                                    'ticketForm',
                                                                    a
                                                                        ? {
                                                                              mode: a,
                                                                          }
                                                                        : {}
                                                                ),
                                                                e.updateView('Chat/ticketForm', n.form))
                                                              : En(e, 'ticketForm'),
                                                              e.setApplicationState({
                                                                  availability: 'offline',
                                                              });
                                                      },
                                                      e => {
                                                          'CONNECTION_LOST' !== e.code ? hs(r) : n.reject();
                                                      }
                                                  );
                                        d().catch(c);
                                    },
                                    e => {
                                        'CONNECTION_LOST' !== e.code ? hs(r) : n.reject();
                                    }
                                );
                        d();
                    } else if ('postchat' === a.properties.formType) {
                        const { answers: i } = n.data.properties,
                            { fields: s } = a.properties;
                        An(e, s, yn(s, i).fields);
                        const { filledForm: o } = _n(a, i);
                        t.sendEvent({
                            chatId: Ae(e),
                            event: o,
                            attachToLastThread: !0,
                        })
                            .then(t => {
                                n.resolve(),
                                    wn(e, n.id, mt(e, t)),
                                    'rating' in i ? us(r, i).finally(() => As(r)) : As(r);
                            })
                            .catch(t => {
                                if (t.message === bt)
                                    return (
                                        Ne(e, Te, {
                                            forced: !0,
                                        }),
                                        Os(r, Fs(e)).then(e => qs(r, e))
                                    );
                                n.reject();
                            });
                    } else if ('ask_for_email' === a.properties.formId) {
                        const { answers: i } = n.data.properties,
                            { filledForm: s } = _n(a, i);
                        t.sendEvent({
                            chatId: Ae(e),
                            event: s,
                            attachToLastThread: !0,
                        })
                            .then(e => {
                                n.resolve(), ms(r, e);
                            })
                            .catch(() => n.reject());
                    }
                    var o;
                },
                requestCustomerToken: () => {
                    t.auth
                        .getToken()
                        .then(t => e.emit('customer_token_response', t))
                        .catch(t => e.emit('customer_token_error', t));
                },
                requestUpdateUser: n => {
                    let {
                            resolve: a,
                            id: r,
                            data: { properties: i },
                        } = n,
                        s = o(n.data, Ds);
                    if (e.getSessionUserId() === r) {
                        if (Rt(e)) {
                            const e = c({
                                name: s.name,
                                email: s.email,
                                sessionFields: i,
                            });
                            t.updateCustomer(e).catch(e => At('update_customer_request_failed', e));
                        }
                        a();
                    }
                },
                requestSetUserProperties: n => {
                    let { resolve: r, id: i, properties: s } = n;
                    e.getSessionUserId() === i &&
                        (Rt(e) &&
                            t
                                .setCustomerSessionFields({
                                    sessionFields: s,
                                })
                                .catch(a),
                        r());
                },
                sendFileEvents: () => {
                    e.setApplicationState({
                        isSendingFileEvents: !0,
                    });
                    const n = [].concat(fn(e));
                    n.filter(e => e.properties.failed).forEach(t =>
                        e.updateEvent(Te, t.id, {
                            properties: {
                                canceled: !0,
                            },
                        })
                    );
                    const a = n
                        .filter(e => {
                            let {
                                type: t,
                                delivered: n,
                                properties: { canceled: a, finished: r },
                            } = e;
                            return 'file' === t && !n && !a && r;
                        })
                        .map(n =>
                            t
                                .sendEvent({
                                    chatId: Ae(e),
                                    event: {
                                        type: 'file',
                                        customId: n.id,
                                        url: n.properties.serverUrl,
                                        alternativeText: n.properties.alternativeText,
                                    },
                                })
                                .then(a => {
                                    e.updateEvent(Te, n.id, {
                                        delivered: !0,
                                    }),
                                        ms(
                                            {
                                                sdk: t,
                                                store: e,
                                            },
                                            a
                                        ),
                                        Promise.resolve().then(() => {
                                            'image' === n.properties.fileType && URL.revokeObjectURL(n.properties.url);
                                        });
                                    const r = n.properties.uploadSource;
                                    ('clipboard' === r || Math.random() < 0.1) &&
                                        vt('file_upload_sent', {
                                            uploadSource: r,
                                        });
                                })
                        );
                    Promise.all(a).finally(() => {
                        e.setApplicationState({
                            isSendingFileEvents: !1,
                        });
                    });
                },
                cancelUpload: t => {
                    let { eventId: n } = t;
                    const a = e.getEvent(Te, n);
                    e.updateEvent(Te, n, {
                        properties: {
                            canceled: !0,
                        },
                    });
                    const r = Ea.getUploadInProgress(n);
                    r && r.cancel(),
                        Promise.resolve().then(() => {
                            'image' === a.properties.fileType && URL.revokeObjectURL(a.properties.url);
                        });
                },
                addMessageReaction: n => {
                    let { eventId: a, reaction: r } = n;
                    const i = e.getEvent(Te, a);
                    t.updateEventProperties({
                        chatId: Ae(e),
                        threadId: i.thread,
                        eventId: i.serverId,
                        properties: {
                            bb9e5b2f1ab480e4a715977b7b1b4279: {
                                message_reaction: r,
                            },
                        },
                    }),
                        (e.getApplicationState('license') === gn || Math.random() < 0.1) &&
                            vt('message_reaction_sent', {
                                reaction: r,
                                messageType: i.type,
                                chatId: Ae(e),
                            });
                },
                startThreadOrSendEvent: n => {
                    if (nn(Te, e)) return void Ea.addToEventQueue(n);
                    const a = () => {
                            Pn(e) && On(e);
                        },
                        r = {
                            store: e,
                            sdk: t,
                        };
                    var i;
                    e.getChat(Te).active
                        ? n && (null == (i = ws(r, n)) || i.then(a))
                        : Es(
                              r,
                              s(
                                  {},
                                  n && {
                                      customerStartingEvent: n.event,
                                  },
                                  {
                                      agentFakeEvent: qt(e, Te),
                                  }
                              )
                          ).then(
                              e => {
                                  Ts(r, e), Ea.clearEventQueue().forEach(e => ws(r, e)), a();
                              },
                              t => {
                                  switch (
                                      (e.updateEvent(Te, null == n ? void 0 : n.event.id, {
                                          failed: !0,
                                      }),
                                      Ea.clearEventQueue().forEach(t => {
                                          e.updateEvent(Te, t.id, {
                                              failed: !0,
                                          });
                                      }),
                                      t.code)
                                  ) {
                                      case 'SERVICE_UNAVAILABLE':
                                          return void ds(e, {
                                              withSystemMessage: !0,
                                              reason: 'service_unavailable',
                                          });
                                      case 'CUSTOMER_BANNED':
                                          return void hs(r);
                                      case 'GROUPS_OFFLINE':
                                          return void ps(r);
                                      default:
                                          return;
                                  }
                              }
                          );
                },
                requestCancelGreeting: n => {
                    Re(e, 'maximized') && Ve(e),
                        on(e, n.id, {
                            force: !0,
                        }),
                        t
                            .cancelGreeting({
                                uniqueId: n.properties.uniqueId,
                            })
                            .catch(a);
                },
                richGreetingButtonClicked: e => {
                    var n;
                    let { button: r, event: i } = e;
                    null != i &&
                        null != (n = i.properties) &&
                        n.uniqueId &&
                        r.buttonId &&
                        t
                            .sendGreetingButtonClicked({
                                greetingUniqueId: i.properties.uniqueId,
                                buttonId: r.buttonId,
                            })
                            .catch(a);
                },
                setApplicationState: n => {
                    let { pageFocused: a } = n;
                    vn(e) && a && (e.setConnectionState(dn), t.connect());
                },
            }))(i, v),
            _ = {
                sdk: v,
                store: i,
            };
        !0 === g.__unsafeProperties.s &&
            i.setApplicationState({
                s: !0,
            }),
            g.prechatForm && i.updateView('Chat/prechat', Mn('prechat', g.prechatForm)),
            g.ticketForm && i.updateView('Chat/ticketForm', Ln(g.ticketForm)),
            g.__unsafeProperties.group.chatBoosters && Nn(i, g.__unsafeProperties.group.chatBoosters);
        const I = zn(
            ha(v, 'greeting_accepted'),
            n(e => {
                var t;
                return (
                    e.uniqueId ===
                    (null == (t = i.getApplicationState('postponedGreeting')) ||
                    null == (t = t.event) ||
                    null == (t = t.properties)
                        ? void 0
                        : t.uniqueId)
                );
            })
        );
        zn(
            e(
                ha(v, 'incoming_greeting'),
                zn(
                    ha(v, 'connected'),
                    n(e => 'greeting' in e),
                    Dn(e => e.greeting)
                )
            ),
            n(e => Wt(i) && e.isExitIntent && !e.accepted),
            Gn(e => {
                i.setApplicationState({
                    postponedGreeting: Jt(i, e),
                }),
                    i.emit('register_exit_intent_listener');
            }),
            Rn(() => ha(i, 'exit_intent_detected')),
            Vn(I),
            d(1),
            n(() =>
                (e => {
                    const { mobile: t, availability: n } = e.getApplicationState(),
                        { active: a } = e.getChat(Te);
                    return !t && !a && 'online' === n && !Ee(e);
                })(i)
            ),
            Rn(() => Bn(As(_))),
            n(() => (e => 'bar' !== ke(e) && we(e))(i)),
            l(() => i.emit('apply_exit_intent_shade'))
        ),
            v.on('thread_properties_deleted', f.threadPropertiesDeleted),
            v.on('thread_properties_updated', f.threadPropertiesUpdated),
            v.on('queue_position_updated', f.queuePositionUpdated),
            v.on('chat_transferred', f.chatTransferred),
            v.on('customer_updated', f.customerUpdated),
            v.on('event_properties_updated', f.eventPropertiesUpdated),
            v.on('event_updated', f.eventUpdated),
            v.on('disconnected', f.disconnected),
            v.on('user_added_to_chat', f.userAddedToChat),
            v.on('user_removed_from_chat', f.userRemovedFromChat),
            v.on('user_data', e => Ft(i, e)),
            ((e, t) => {
                e.on('send_snapshot', n => {
                    const { requestId: r, snapshot: i, screen: s } = n;
                    t.uploadFile({
                        file: new Blob([i], {
                            type: 'text/plain;charset=utf-8',
                        }),
                    })
                        .promise.then(n => {
                            t.sendEvent({
                                chatId: Ae(e),
                                event: {
                                    type: 'custom',
                                    customId: 'cyber-finger-snapshot-' + r,
                                    content: {
                                        url: n.url,
                                        screen: s,
                                    },
                                },
                            }),
                                vt('snapshot_sent', {
                                    chatId: Ae(e),
                                });
                        })
                        .catch(a);
                });
            })(i, v),
            v.on('greeting_canceled', f.greetingCanceled),
            v.on('connected', f.connected),
            Hn(g, i),
            'modern' === Qn(i) && 'Homescreen' === i.getCurrentView() && i.setCurrentView('Chat');
        const S = i.getApplicationState('defaultWidget');
        Wn(i) &&
            'openwidget' !== S &&
            (Jn(i, e => bn(_.sdk.auth.getToken, e)), !i.getCurrentView() && Xn(i) && i.setCurrentView('Homescreen')),
            v.once('customer_id', e => ze(i, e)),
            v.on('identity_changed', e => {
                let { newId: t } = e;
                ((e, t) => {
                    let { newId: n } = t;
                    e.clearChatServerId(Te),
                        Ne(e, Te, {
                            forced: !0,
                        }),
                        e.updateChat(Te, {
                            active: !1,
                            properties: {
                                ended: !1,
                                queued: !1,
                                currentAgent: null,
                            },
                        }),
                        ze(e, n);
                    const a = e.getSessionUserId();
                    e.updateUser(a, {
                        name: null,
                        email: null,
                    }),
                        e.setUserProperties(a, {});
                    const r = {
                        messageDraft: null,
                        invitationHiddenIds: [],
                        invitationDisplayedIds: [],
                        greetingsMuted: !1,
                        postponedGreeting: null,
                    };
                    e.setApplicationState({
                        hasUnseenEvents: !1,
                        invitation: {
                            current: null,
                            hiddenIds: r.invitationHiddenIds,
                            displayedIds: r.invitationDisplayedIds,
                        },
                        messageDraft: r.messageDraft,
                        greetingsMuted: r.greetingsMuted,
                        postponedGreeting: r.postponedGreeting,
                        isReturning: !1,
                        clientChatNumber: 0,
                        clientVisitNumber: 0,
                        clientLastVisitTimestamp: null,
                        clientPageViewsCount: 0,
                    });
                })(i, {
                    newId: t,
                });
            });
        const b = Yn(i, Be),
            C = e => zn(b, Rn(e)),
            w = zn(
                Zn(i, e => _a(e, 'maximized')),
                n(Boolean),
                Dn(() => ({
                    type: 'maximized',
                })),
                Kn
            ),
            T = zn(
                Zn(i, e => e.localization),
                n(e => Object.keys(e).length > 1),
                d(1),
                p
            );
        Ea.setLocalizationPromise(T);
        const E = zn(
            Zn(i, () => i.getSessionUser().serverId),
            n(Boolean),
            d(1),
            p
        );
        if (m) {
            if (Math.random() <= 0.01 && 'onLine' in navigator) {
                const e = setTimeout(() => {
                    navigator.onLine && cn('unsuccessful_first_connect', {});
                }, 3e4);
                Ea.setReportConnectionUnsuccessfulTimerId(e);
            }
            i.setApplicationState({
                clientLimitExceededLifted: !0,
            });
        } else
            Promise.all([T, E]).then(n => {
                let [a] = n;
                i.setLocalization(a),
                    ((e, t) => {
                        e.setApplicationState({
                            availability: ts(e, t) ? 'online' : 'offline',
                        });
                    })(i, g.onlineGroupIds),
                    i.setConnectionState(ln),
                    os(i),
                    ls(i);
                const r = ((s = document), e(...['click', 'touchstart'].map(e => t(s, e))));
                var s;
                zn(
                    e(r, w),
                    d(1),
                    l(() => {
                        i.setApplicationState({
                            clientLimitExceededLifted: !0,
                        }),
                            v.connect();
                    })
                );
            });
        'ononline' in window &&
            (v.on('connection_unstable', () => {
                i.setConnectionState(dn);
            }),
            v.on('connection_recovered', () => {
                i.setConnectionState(Yt);
            })),
            v.on('incoming_greeting', f.incomingGreeting),
            v.on('availability_updated', f.availabilityUpdated),
            v.on('events_marked_as_seen', f.eventsMarkedAsSeen),
            v.on('incoming_event', f.incomingEvent),
            v.on('incoming_event_preview', f.incomingEventPreview),
            v.on('chat_deactivated', f.chatDeactivated),
            v.on('incoming_chat', f.incomingChat);
        const k = zn(
                ha(v, 'incoming_typing_indicator'),
                n(e => {
                    if (!e.typingIndicator.isTyping || !as(i, e.chatId, e.typingIndicator.authorId)) return !1;
                    const t = i.getChat(Te).properties.agentActivity;
                    return 'thinking' !== (null == t ? void 0 : t.type);
                }),
                Dn(() => ({
                    type: 'typing',
                }))
            ),
            A = zn(
                ha(v, 'incoming_typing_indicator'),
                n(e => {
                    if (e.typingIndicator.isTyping || !as(i, e.chatId, e.typingIndicator.authorId)) return !1;
                    const t = i.getChat(Te).properties.agentActivity;
                    return 'thinking' !== (null == t ? void 0 : t.type);
                }),
                Rn(() =>
                    zn(
                        Ia(Wa ? 0 : 200),
                        Dn(() => null)
                    )
                )
            ),
            O = zn(
                ha(v, 'incoming_thinking_indicator'),
                n(e => as(i, e.chatId, e.authorId)),
                Dn(e => ({
                    type: 'thinking',
                    customId: e.customId,
                    title: e.title,
                    description: e.description,
                    authorId: e.authorId,
                }))
            ),
            q = zn(
                e(ha(v, 'incoming_event'), ha(v, 'incoming_event_preview')),
                n(e => {
                    let { chatId: t, event: n } = e;
                    return (
                        t === Ae(i) &&
                        n.authorId !== i.getSessionUser().serverId &&
                        'system' !== n.authorId &&
                        as(i, t, n.authorId)
                    );
                }),
                Dn(e => {
                    let { event: t } = e;
                    const n = i.getChat(Te).properties.agentActivity;
                    return 'typing' === (null == n ? void 0 : n.type)
                        ? null
                        : 'thinking' === (null == n ? void 0 : n.type) && n.customId
                          ? t.customId === n.customId
                              ? null
                              : n
                          : null;
                })
            );
        zn(
            e(
                zn(
                    k,
                    n(() => (e => !e.getApplicationState('messageDraft'))(i)),
                    n(() => rs(i))
                ),
                A,
                zn(
                    O,
                    n(() => rs(i))
                ),
                q
            ),
            Rn(e =>
                'typing' === (null == e ? void 0 : e.type)
                    ? (
                          (...e) =>
                          (t, n) => {
                              if (0 !== t) return;
                              const a = e.length;
                              if (0 === a) return n(0, () => {}), void n(2);
                              let r,
                                  i = 0;
                              const s = (e, t) => {
                                  r(e, t);
                              };
                              !(function t() {
                                  i !== a
                                      ? e[i](0, (e, a) => {
                                            0 === e
                                                ? ((r = a), 0 === i ? n(0, s) : r(1))
                                                : 2 === e && a
                                                  ? n(2, a)
                                                  : 2 === e
                                                    ? (i++, t())
                                                    : n(e, a);
                                        })
                                      : n(2);
                              })();
                          }
                      )(
                          tr(e),
                          zn(
                              Ia(1e4),
                              Dn(() => null)
                          )
                      )
                    : tr(e)
            ),
            $n(),
            l(e => {
                i.updateChat(Te, {
                    properties: {
                        agentActivity: e,
                    },
                });
            })
        ),
            zn(
                ha(v, 'incoming_welcome_message'),
                Dn(e => ea(i, e)),
                Rn(e =>
                    zn(
                        Zn(i, () => i.hasUser(e.author)),
                        n(Boolean),
                        d(1),
                        Dn(() => e)
                    )
                ),
                l(e => {
                    ta(i, e), Ea.setPendingAsyncFlow('requestingPredictedWelcomeMessage', !1);
                })
            ),
            zn(
                Zn(i, () => i.getChat(Te).properties.loadingHistory),
                n(Boolean),
                l(() => Ss(i))
            ),
            i.on('request_update_chat', y.requestUpdateChat),
            i.on('request_update_event', y.requestUpdateEvent),
            i.on('request_customer_token', y.requestCustomerToken),
            i.on('request_update_user', y.requestUpdateUser),
            i.on('request_set_user_properties', y.requestSetUserProperties),
            i.on('send_file_events', y.sendFileEvents),
            i.on('cancel_upload', y.cancelUpload),
            i.on('add_message_reaction', y.addMessageReaction),
            i.on('start_thread', y.startThreadOrSendEvent),
            i.on('send_event', y.startThreadOrSendEvent),
            i.on('request_cancel_greeting', y.requestCancelGreeting),
            i.on('rich_greeting_button_clicked', y.richGreetingButtonClicked),
            i.on('set_application_state', y.setApplicationState),
            zn(
                w,
                l(() => gs(i))
            );
        const F = zn(
            Zn(i, e => e.application.destroyed),
            n(Boolean),
            d(1),
            Kn
        );
        zn(
            b,
            d(1),
            Dn(() => {
                const e = ma(P(['organizationId', 'group', 'requestedGroup'], i.getApplicationState()));
                return [na('session') && window.sessionStorage.getItem(e), e];
            }),
            n(e => {
                let [t] = e;
                return Boolean(t);
            }),
            l(e => {
                let [t, n] = e;
                ((e, t) => {
                    let n;
                    const a = $i(e);
                    try {
                        n = JSON.parse(t);
                    } catch (r) {
                        return;
                    }
                    n &&
                        a &&
                        n.forEach(t => {
                            e.getEvent(Te, t.id) ||
                                We(e, Te, {
                                    thread: a,
                                    id: t.id,
                                    type: 'file',
                                    own: !0,
                                    author: e.getSessionUser().id,
                                    delivered: !1,
                                    failed: !1,
                                    properties: t,
                                });
                        });
                })(i, t),
                    window.sessionStorage.removeItem(n);
            })
        );
        const [U, j] = zn(
            Zn(i, e => e.application.availability),
            Sa(1),
            u,
            Dn(e => ({
                type: e,
            })),
            ((x = e => {
                let { type: t } = e;
                return 'online' === t;
            }),
            function (e) {
                return [
                    n(x)(e),
                    n(
                        ((t = x),
                        function (e) {
                            return !t(e);
                        })
                    )(e),
                ];
                var t;
            })
        );
        var x, M;
        zn(
            C(() => j),
            n(() => ns(i)),
            l(() =>
                (e => {
                    !Je(e, 'prechat') &&
                        Xe(e) &&
                        Ye(e) &&
                        'offline' === e.getApplicationState().availability &&
                        !e.getChat(Te).active &&
                        Ze(e),
                        Je(e, 'prechat') && (Ke(e), Xe(e) && Ze(e)),
                        os(e);
                })(i)
            )
        ),
            zn(
                U,
                n(() => ns(i)),
                l(() =>
                    (e => {
                        e.getView('minimized').hidden && gs(e),
                            !$e(e) &&
                                we(e) &&
                                Re(e, 'hidden') &&
                                !e.getApplicationState('isMinimizedForcefullyDisabled') &&
                                Ve(e);
                    })(i)
                )
            ),
            zn(
                C(() => {
                    if (!Ye(i)) return er;
                    const t = Zn(i, () => Je(i, 'prechat'));
                    return zn(
                        e(w, t),
                        n(() => Je(i, 'prechat')),
                        Rn(() => {
                            const e = i.getLastEvent(Te);
                            return zn(
                                Bn(
                                    ((e, t) => {
                                        const n = tt(e => 'groupSelect' === e.meta, t);
                                        if (-1 === n) return Promise.resolve(null);
                                        const a = t[n],
                                            r = a.options.map(e => e.groupId);
                                        return r.length > 20
                                            ? Promise.resolve(null)
                                            : ka(e, {
                                                  groupIds: r,
                                              }).then(e =>
                                                  nt(
                                                      n,
                                                      s({}, a, {
                                                          options: a.options.map(t =>
                                                              s({}, t, {
                                                                  meta: {
                                                                      online: 'online' === e[t.groupId],
                                                                  },
                                                              })
                                                          ),
                                                      }),
                                                      t
                                                  )
                                              );
                                    })(_, e.properties.fields)
                                ),
                                Za
                            );
                        })
                    );
                }),
                n(e => e && Je(i, 'prechat')),
                l(e => {
                    const { id: t } = i.getLastEvent(Te);
                    return i.updateEvent(Te, t, {
                        properties: {
                            fields: e,
                        },
                    });
                })
            ),
            zn(
                C(() =>
                    zn(
                        Zn(i, () => i.getChat(Te).properties.startChatAgainPending),
                        n(Boolean)
                    )
                ),
                Rn(() => Bn(Os(_, Fs(i)))),
                l(e => {
                    Ne(i, Te, {
                        chatId: i.getChat(Te).serverId,
                    }),
                        qs(_, e);
                })
            ),
            zn(
                e(w, U, j),
                ((M = b),
                function (e) {
                    return function (t, n) {
                        if (0 === t) {
                            var a,
                                r,
                                i = !1;
                            e(0, function (e, t) {
                                0 === e &&
                                    ((a = t),
                                    M(0, function (e, t) {
                                        0 === e ? (r = t)(1) : 1 === e && ((i = !0), r(2));
                                    })),
                                    1 === e ? (i ? n(1, t) : a(1)) : n(e, t);
                            });
                        }
                    };
                }),
                n(() => ns(i) && i.getApplicationState().eagerFetchingMode),
                aa(() => Bn(Os(_, Fs(i)))),
                Vn(F),
                l(e => qs(_, e))
            ),
            zn(
                C(() =>
                    zn(
                        w,
                        n(() => !i.getApplicationState().eagerFetchingMode)
                    )
                ),
                Rn(() => {
                    const e = i.getChat(Te).serverId;
                    return Bn(Promise.all([Os(_, Fs(i)), Le(i) && e && wa(_, e)].filter(Boolean)));
                }),
                Vn(F),
                l(e => {
                    let [t, n] = e;
                    if (n) {
                        Aa(_, i.getChat(Te).serverId, n.iterator), Is(i, n.hasMore);
                        const e = xe(i) ? Qe(i, n.threads) : n.threads,
                            t = He(e => {
                                let { events: t } = e;
                                return t;
                            }, e).filter(e => !i.hasEvent(Te, e.id));
                        t.length > 0 && i.addHistoryEvents(Te, t);
                        const a = i.getChat(Te).properties.previousThread,
                            r = e.length ? rt(e).id : null,
                            o = !(a && a === r);
                        i.updateChat(Te, {
                            properties: s(
                                {
                                    eventsSeenUpToMap: n.eventsSeenUpToMap,
                                },
                                o && {
                                    lastThread: r,
                                }
                            ),
                        });
                    }
                    i.setApplicationState({
                        eagerFetchingMode: !0,
                    }),
                        qs(_, t);
                })
            ),
            zn(
                Zn(i, e => e.application.page),
                Sa(1),
                Vn(F),
                l(e => {
                    let { url: t, title: n } = e;
                    v.updateCustomerPage({
                        url: t,
                        title: n,
                    });
                })
            ),
            zn(
                Zn(i, () => i.getUnseenCount(Te) > 0),
                n(ba),
                l(() => {
                    clearTimeout(Ea.getMinimizedTimeouts().indicatorNotAnimated),
                        i.updateView(
                            'minimized',
                            s({}, i.getView('minimized'), {
                                animateUnseenEventIndicator: !0,
                            })
                        ),
                        i.emit('render-minimized');
                    const e = setTimeout(() => {
                        i.updateView(
                            'minimized',
                            s({}, i.getView('minimized'), {
                                animateUnseenEventIndicator: !1,
                            })
                        ),
                            i.emit('render-minimized');
                    }, 500);
                    Ea.setMinimizedTimeout('indicatorNotAnimated', e);
                })
            );
        const L = Ra(ca, e => {
            v.setSneakPeek({
                chatId: Ae(i),
                sneakPeekText: e,
            });
        });
        zn(
            Zn(i, e => e.application.messageDraft),
            $n(),
            n(() => i.getChat(Te).active),
            l(e => {
                'string' != typeof e ? L.cancel() : L(e);
            })
        ),
            ra(i) &&
                zn(
                    w,
                    d(1),
                    l(() => {
                        var e, t;
                        const n = Fn(),
                            a =
                                null == (e = i.getApplicationState('config').properties.license[n])
                                    ? void 0
                                    : e.hdLicenseID,
                            r = null != (t = i.getApplicationState('group')) ? t : 0;
                        va(() => Va(a, r), {
                            retriesCount: Wa ? 2 : 10,
                            minTime: Wa ? 100 : 1e3,
                            maxTime: Wa ? 1e3 : 15e3,
                        }).then(
                            e => {
                                i.updateView('HelpdeskTicketForm', {
                                    helpdeskFormConfiguration: e,
                                    isLoading: !1,
                                });
                            },
                            e => {
                                i.updateView('HelpdeskTicketForm', {
                                    isLoading: !1,
                                    hasFetchingError: !0,
                                }),
                                    At('helpdesk_form_fetching_failed', e);
                            }
                        );
                    })
                ),
            zn(
                Zn(i, () => i.getConnectionState()),
                n(e => e === dn),
                l(() => {
                    i.setApplicationState({
                        disableSendingMessage: !0,
                    }),
                        zn(
                            e(
                                zn(
                                    Ia(Wa ? 500 : 8e3),
                                    Dn(() => ({
                                        reason: 'timeout',
                                    }))
                                ),
                                zn(
                                    ha(i, ia),
                                    Dn(() => ({
                                        reason: 'message_send_attempt',
                                    }))
                                ),
                                zn(
                                    Zn(i, () => i.getConnectionState()),
                                    n(e => e !== dn),
                                    Dn(() => ({
                                        reason: 'connection_state_change',
                                    }))
                                )
                            ),
                            d(1),
                            l(e => {
                                let { reason: t } = e;
                                i.setApplicationState({
                                    disableSendingMessage: !1,
                                }),
                                    i.getConnectionState() === dn && i.setConnectionState(Xt),
                                    zn(
                                        Zn(i, () => i.getConnectionState()),
                                        n(e => e === Yt),
                                        d(1),
                                        l(() => {
                                            Math.random() < 0.1 &&
                                                vt('scheduled_reconnecting_ended', {
                                                    reason: t,
                                                });
                                        })
                                    );
                            })
                        );
                })
            ),
            zn(
                Zn(i, () => i.getConnectionState()),
                n(e => e === pn || e === Xt),
                l(() => {
                    const e = sa(i);
                    e &&
                        !Re(i, 'maximized') &&
                        (i.removeEvent(Te, e.id), setTimeout(() => i.emit('render-minimized'), 0)),
                        Ea.getIsPendingAsyncFlow('requestingPredictedWelcomeMessage') &&
                            Ea.setPendingAsyncFlow('requestingPredictedWelcomeMessage', !1);
                })
            ),
            zn(
                Zn(i, e => e.application.privacyPolicyBannerState),
                n(e => 'closing' !== e),
                $n(),
                l(e => {
                    const { organizationId: t, group: n } = i.getApplicationState();
                    if ('unset' === e) {
                        const e = ((e, t) => {
                            try {
                                const n = be.getItem(Wi(e, t));
                                return n
                                    ? JSON.parse(n)
                                    : {
                                          hidden: !1,
                                      };
                            } catch (n) {
                                return (
                                    console.error('Error getting privacy policy state:', n),
                                    {
                                        hidden: !1,
                                    }
                                );
                            }
                        })(t, n);
                        i.setApplicationState({
                            privacyPolicyBannerState: e.hidden ? 'hidden' : 'visible',
                        });
                    } else
                        ((e, t, n) => {
                            be.setItem(Wi(e, t), JSON.stringify(n));
                        })(t, n, {
                            hidden: 'hidden' === e,
                        });
                })
            ),
            zn(
                Zn(i, e => e.application.websiteTextSelection),
                n(e => {
                    let { state: t } = e;
                    return 'visible' !== t;
                }),
                $n(),
                l(() => {
                    i.getApplicationState('minimizedMessageInput').isVisible &&
                        !oa(i) &&
                        setTimeout(() => i.emit('render-minimized'), 0);
                })
            );
    };
export { Gs as default };
